act_info.c:      else if( obj->short_descr )
act_info.c:         mudstrlcat( buf, obj->short_descr, MAX_STRING_LENGTH );
act_info.c:      else if( obj->description )
act_info.c:         mudstrlcat( buf, obj->description, MAX_STRING_LENGTH );
act_info.c:   for( obj = list; obj; obj = obj->next_content )
act_info.c:   for( obj = list; obj; obj = obj->next_content )
act_info.c:      if( obj->wear_loc == WEAR_NONE
act_info.c:          && can_see_obj( ch, obj ) && ( obj->item_type != ITEM_TRAP || IS_AFFECTED( ch, AFF_DETECTTRAPS ) ) )
act_info.c:                  prgnShow[iShow] += obj->count;
act_info.c:         pitShow[nShow] = obj->item_type;
act_info.c:            prgnShow[nShow] = obj->count;
act_info.c:      if( ch->carry_weight + obj->weight > can_carry_w( ch ) )
act_info.c:      count = obj->count;
act_info.c:      obj->count = 1;
act_info.c:      obj->count = count;
act_info.c:         show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c:      switch ( obj->item_type )
act_info.c:            if( obj->value[1] <= 0 )
act_info.c:               LIQ_TABLE *liq = get_liq_vnum( obj->value[2] );
act_info.c:                          obj->value[1] < obj->value[0] / 4
act_info.c:                          ? "less than" : obj->value[1] < 3 * obj->value[0] / 4 ? "about" : "more than", liq->color );
act_info.c:            if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_info.c:            count = obj->count;
act_info.c:            obj->count = 1;
act_info.c:            if( obj->item_type == ITEM_CONTAINER )
act_info.c:            obj->count = count;
act_info.c:            show_list_to_char( obj->first_content, ch, TRUE, TRUE );
act_info.c:   for( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c:            if( obj->item_type == ITEM_PUDDLE )
act_info.c:               LIQ_TABLE *liq = get_liq_vnum( obj->value[2] );
act_info.c:   for( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( ( pdesc = get_extra_descr( arg, obj->pIndexData->first_extradesc ) ) != NULL )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:         if( nifty_is_name_prefix( arg, obj->name ) )
act_info.c:            if( ( cnt += obj->count ) < number )
act_info.c:            pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
act_info.c:               pdesc = get_extra_descr( obj->name, obj->first_extradesc );
act_info.c:            if( obj->item_type == ITEM_PUDDLE )
act_info.c:               LIQ_TABLE *liq = get_liq_vnum( obj->value[2] );
act_info.c:      switch ( obj->item_type )
act_info.c:            if( obj->value[1] == 0 )
act_info.c:               obj->value[1] = obj->value[0];
act_info.c:            if( obj->value[1] == 0 )
act_info.c:               obj->value[1] = 1;
act_info.c:            dam = ( short )( ( obj->value[0] * 10 ) / obj->value[1] );
act_info.c:            for( ed = obj->first_extradesc; ed; ed = ed->next )
act_info.c:                       obj->short_descr, count, count == 1 ? "page" : "pages", obj->value[0] );
act_info.c:            dam = INIT_WEAPON_CONDITION - obj->value[0];
act_info.c:            dam = obj->value[2];
act_info.c:            if( obj->timer > 0 && obj->value[1] > 0 )
act_info.c:               dam = ( obj->timer * 10 ) / obj->value[1];
act_info.c:            if( obj->item_type == ITEM_FOOD )
act_info.c:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c:            if( IS_SET( obj->value[0], TRIG_UP ) )
act_info.c:            short timerfrac = obj->timer;
act_info.c:            if( obj->item_type == ITEM_CORPSE_PC )
act_info.c:               timerfrac = ( int )obj->timer / 8 + 1;
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:         ch_printf( ch, "%s is not a container.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:         ch_printf( ch, "%s is already open.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:         ch_printf( ch, "%s is locked.\r\n", capitalize( obj->short_descr ) );
act_move.c:      REMOVE_BIT( obj->value[1], CONT_CLOSED );
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:         ch_printf( ch, "%s is not a container.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:         ch_printf( ch, "%s is already closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSEABLE ) )
act_move.c:         ch_printf( ch, "%s cannot be opened or closed.\r\n", capitalize( obj->short_descr ) );
act_move.c:      SET_BIT( obj->value[1], CONT_CLOSED );
act_move.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_move.c:      if( obj->pIndexData->vnum == key || ( obj->item_type == ITEM_KEY && obj->value[0] == key ) )
act_move.c:      else if( obj->item_type == ITEM_KEYRING )
act_move.c:         for( obj2 = obj->first_content; obj2; obj2 = obj2->next_content )
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:      if( obj->value[2] < 0 )
act_move.c:      if( ( key = has_key( ch, obj->value[2] ) ) == NULL )
act_move.c:      if( IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:      SET_BIT( obj->value[1], CONT_LOCKED );
act_move.c:      if( obj->item_type != ITEM_CONTAINER )
act_move.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
act_move.c:      if( obj->value[2] < 0 )
act_move.c:      if( ( key = has_key( ch, obj->value[2] ) ) == NULL )
act_move.c:      if( !IS_SET( obj->value[1], CONT_LOCKED ) )
act_move.c:      REMOVE_BIT( obj->value[1], CONT_LOCKED );
act_move.c:      if( IS_SET( obj->value[1], CONT_EATKEY ) )
act_move.c:         obj_next = obj->next_content;
act_move.c:         obj_next = obj->next_content;
act_move.c:         switch ( obj->item_type )
act_obj.c:   resist += ( obj->level / 10 ) - 2;
act_obj.c:   if( obj->item_type == ITEM_ARMOR || obj->item_type == ITEM_WEAPON )
act_obj.c:      resist += ( obj->value[0] / 2 ) - 2;
act_obj.c:   if( IS_SET( obj->magic_flags, ITEM_PKDISARMED ) && !IS_NPC( ch ) )
act_obj.c:         if( !is_name( ch->name, obj->action_desc ) && !IS_IMMORTAL( ch ) )
act_obj.c:            REMOVE_BIT( obj->magic_flags, ITEM_PKDISARMED );
act_obj.c:            STRFREE( obj->action_desc );
act_obj.c:            obj->action_desc = STRALLOC( "" );
act_obj.c:      act( AT_PLAIN, "$d: you can't carry that many items.", ch, NULL, obj->short_descr, TO_CHAR );
act_obj.c:      weight = obj->weight;
act_obj.c:   if( obj->item_type != ITEM_MONEY )
act_obj.c:      if( obj->in_obj )
act_obj.c:         OBJ_DATA *tobj = obj->in_obj;
act_obj.c:         if( tobj->item_type == ITEM_CONTAINER && IS_OBJ_STAT( tobj, ITEM_MAGIC ) )
act_obj.c:         while( tobj->in_obj )
act_obj.c:            tobj = tobj->in_obj;
act_obj.c:            if( tobj->item_type == ITEM_CONTAINER && IS_OBJ_STAT( tobj, ITEM_MAGIC ) )
act_obj.c:         if( !tobj->carried_by || tobj->carried_by != ch || checkweight )
act_obj.c:               act( AT_PLAIN, "$d: you can't carry that much weight.", ch, NULL, obj->short_descr, TO_CHAR );
act_obj.c:         act( AT_PLAIN, "$d: you can't carry that much weight.", ch, NULL, obj->short_descr, TO_CHAR );
act_obj.c:   if( obj->item_type == ITEM_MONEY )
act_obj.c:      amt = obj->value[0] * obj->count;
act_obj.c:            obj_next = obj->prev_content;
act_obj.c:            if( ( fAll || nifty_is_name( chk, obj->name ) ) && can_see_obj( ch, obj ) )
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:               cnt += obj->count;
act_obj.c:            obj_next = obj->next_content;
act_obj.c:            if( ( fAll || nifty_is_name( chk, obj->name ) ) && can_see_obj( ch, obj ) )
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:               cnt += obj->count;
act_obj.c:      if( container->item_type == ITEM_KEYRING && obj->item_type != ITEM_KEY )
act_obj.c:      if( container->item_type == ITEM_QUIVER && obj->item_type != ITEM_PROJECTILE )
act_obj.c:         int tweight = ( get_real_obj_weight( container ) / container->count ) + ( get_real_obj_weight( obj ) / obj->count );
act_obj.c:         && container->in_room->max_weight < get_real_obj_weight( obj ) / obj->count + container->in_room->weight )
act_obj.c:      count = obj->count;
act_obj.c:      obj->count = 1;
act_obj.c:      obj->count = count;
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( ( fAll || nifty_is_name( chk, obj->name ) )
act_obj.c:             && obj->wear_loc == WEAR_NONE
act_obj.c:             && ( container->item_type != ITEM_KEYRING || obj->item_type == ITEM_KEY )
act_obj.c:             && ( container->item_type != ITEM_QUIVER || obj->item_type == ITEM_PROJECTILE )
act_obj.c:            if( number && ( cnt + obj->count ) > number )
act_obj.c:            cnt += obj->count;
act_obj.c:            obj_next = obj->next_content;
act_obj.c:            switch ( obj->pIndexData->vnum )
act_obj.c:                  number += obj->value[0];
act_obj.c:         && ch->in_room->max_weight < get_real_obj_weight( obj ) / obj->count + ch->in_room->weight )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( ( fAll || nifty_is_name( chk, obj->name ) )
act_obj.c:            && can_see_obj( ch, obj ) && obj->wear_loc == WEAR_NONE && can_drop_obj( ch, obj )
act_obj.c:            && ( !ch->in_room->max_weight || ch->in_room->max_weight > get_real_obj_weight( obj ) / obj->count + ch->in_room->weight ) )
act_obj.c:            if( HAS_PROG( obj->pIndexData, DROP_PROG ) && obj->count > 1 )
act_obj.c:               if( number && ( cnt + obj->count ) > number )
act_obj.c:               cnt += obj->count;
act_obj.c:   if( obj->wear_loc != WEAR_NONE )
act_obj.c:   if( victim->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( victim ) )
act_obj.c:   if( victim->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( victim ) )
act_obj.c:   ch = obj->carried_by;
act_obj.c:   else if( obj->in_room && ( ch = obj->in_room->first_person ) != NULL )
act_obj.c:   if( obj->item_type != ITEM_LIGHT )
act_obj.c:   switch ( obj->item_type )
act_obj.c:         if( --obj->value[3] <= 0 )
act_obj.c:               obj->value[3] = 1;
act_obj.c:         if( --obj->value[0] <= 0 )
act_obj.c:               obj->value[0] = 1;
act_obj.c:         if( ch && obj->value[0] >= 1 )
act_obj.c:            ch->armor += apply_ac( obj, obj->wear_loc );
act_obj.c:         if( --obj->value[0] <= 0 )
act_obj.c:               obj->value[0] = 1;
act_obj.c:               ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:         else if( ch && obj->value[0] >= 1 )
act_obj.c:            ch->armor -= apply_ac( obj, obj->wear_loc );
act_obj.c:         if( --obj->value[0] <= 0 )
act_obj.c:               obj->value[0] = 1;
act_obj.c:    	log_printf( "%s scrapped %s (vnum: %d)", ch->name, obj->short_descr, obj->pIndexData->vnum );
act_obj.c:      act( AT_PLAIN, "$d: you can't carry that many items.", ch, NULL, obj->short_descr, TO_CHAR );
act_obj.c:      tmpobj->wear_loc = WEAR_WIELD;
act_obj.c:   short objlayers = obj->pIndexData->layers;
act_obj.c:   if( get_trust( ch ) < obj->level )
act_obj.c:      ch_printf( ch, "You must be level %d to use this object.\r\n", obj->level );
act_obj.c:   if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && str_cmp( ch->name, obj->owner ) )
act_obj.c:      if( obj->carried_by )
act_obj.c:   if( obj->item_type == ITEM_LIGHT )
act_obj.c:         if( obj->item_type == ITEM_WAND
act_obj.c:             || obj->item_type == ITEM_STAFF
act_obj.c:             || obj->item_type == ITEM_FOOD
act_obj.c:             || obj->item_type == ITEM_COOK
act_obj.c:             || obj->item_type == ITEM_PILL
act_obj.c:             || obj->item_type == ITEM_POTION
act_obj.c:             || obj->item_type == ITEM_SCROLL
act_obj.c:             || obj->item_type == ITEM_DRINK_CON
act_obj.c:             || obj->item_type == ITEM_BLOOD
act_obj.c:             || obj->item_type == ITEM_PIPE
act_obj.c:             || obj->item_type == ITEM_HERB || obj->item_type == ITEM_KEY || !oprog_use_trigger( ch, obj, NULL, NULL ) )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
act_obj.c:         obj_next = obj->next_content;
act_obj.c:         if( obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) )
act_obj.c:            remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:   if( ( obj_next = get_eq_char( ch, obj->wear_loc ) ) != obj )
act_obj.c:   remove_obj( ch, obj->wear_loc, TRUE );
act_obj.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
act_obj.c:      if( obj->item_type == ITEM_SHOVEL )
act_obj.c:   if( obj->weight > ( UMAX( 5, ( can_carry_w( ch ) / 10 ) ) ) && !shovel )
act_obj.c:   move = ( obj->weight * 50 * ( shovel ? 1 : 5 ) ) / UMAX( 1, can_carry_w( ch ) );
act_obj.c:   if( obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_CORPSE_PC )
act_obj.c:   xSET_BIT( obj->extra_flags, ITEM_BURIED );
act_obj.c:   if( IS_SET( obj->magic_flags, ITEM_PKDISARMED ) && !IS_NPC( ch ) && !IS_IMMORTAL( ch ) )
act_obj.c:         if( ch->level - obj->value[5] > 5 || obj->value[5] - ch->level > 5 )
act_obj.c:   if( obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_CORPSE_PC )
act_obj.c:   if( obj->item_type == ITEM_PAPER )
act_obj.c:   if( obj->item_type != ITEM_PAPER )
act_obj.c:   if( cur_obj == obj->serial )
act_obj.c:                    obj->name, aoran( item_type_name( obj ) ), extra_bit_name( &obj->extra_flags ),
act_obj.c:/*		magic_bit_name( obj->magic_flags ), -- currently unused */
act_obj.c:                    obj->weight, obj->cost, obj->level );
act_obj.c:         if( obj->item_type != ITEM_LIGHT && obj->wear_flags - 1 > 0 )
act_obj.c:            ch_printf( ch, "Item's wear location: %s\r\n", flag_string( obj->wear_flags - 1, w_flags ) );
act_obj.c:         switch ( obj->item_type )
act_obj.c:               ch_printf( ch, "%s appears to %s.\r\n", capitalize( obj->short_descr ),
act_obj.c:                          obj->value[0] < 76 ? "have a small capacity" :
act_obj.c:                          obj->value[0] < 150 ? "have a small to medium capacity" :
act_obj.c:                          obj->value[0] < 300 ? "have a medium capacity" :
act_obj.c:                          obj->value[0] < 500 ? "have a medium to large capacity" :
act_obj.c:                          obj->value[0] < 751 ? "have a large capacity" : "have a giant capacity" );
act_obj.c:               ch_printf( ch, "Level %d spells of:", obj->value[0] );
act_obj.c:               if( obj->value[1] >= 0 && obj->value[1] < num_skills )
act_obj.c:                  send_to_char( skill_table[obj->value[1]]->name, ch );
act_obj.c:               if( obj->value[2] >= 0 && obj->value[2] < num_skills )
act_obj.c:                  send_to_char( skill_table[obj->value[2]]->name, ch );
act_obj.c:               if( obj->value[3] >= 0 && obj->value[3] < num_skills )
act_obj.c:                  send_to_char( skill_table[obj->value[3]]->name, ch );
act_obj.c:               ch_printf( ch, "Has %d(%d) charges of level %d", obj->value[1], obj->value[2], obj->value[0] );
act_obj.c:               if( obj->value[3] >= 0 && obj->value[3] < num_skills )
act_obj.c:                  send_to_char( skill_table[obj->value[3]]->name, ch );
act_obj.c:                          obj->value[1], obj->value[2],
act_obj.c:                          ( obj->value[1] + obj->value[2] ) / 2,
act_obj.c:               ch_printf( ch, "Armor class is %d.\r\n", obj->value[0] );
act_obj.c:         for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
act_obj.c:         for( paf = obj->first_affect; paf; paf = paf->next )
act_obj.c:         if( ( obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_KEYRING
act_obj.c:               || obj->item_type == ITEM_QUIVER ) && obj->first_content )
act_obj.c:            show_list_to_char( obj->first_content, ch, TRUE, FALSE );
act_obj.c:   if( obj->timer > 0 )
act_obj.c:      if( auction->history[i] == obj->pIndexData )
act_obj.c:      switch ( obj->item_type )
act_obj.c:               auction->history[0] = obj->pIndexData;
act_obj.c:            snprintf( buf, MAX_STRING_LENGTH, "A new item is being auctioned: %s at %d gold.", obj->short_descr,
act_obj.c:   if( !obj->in_room || is_falling )
act_obj.c:   if( xIS_SET( obj->in_room->room_flags, ROOM_NOFLOOR ) && CAN_GO( obj, DIR_DOWN ) && !IS_OBJ_STAT( obj, ITEM_MAGIC ) )
act_obj.c:      pexit = get_exit( obj->in_room, DIR_DOWN );
act_obj.c:      if( obj->in_room == to_room )
act_obj.c:      if( obj->in_room->first_person )
act_obj.c:         act( AT_PLAIN, "$p falls far below...", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:         act( AT_PLAIN, "$p falls far below...", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:      if( obj->in_room->first_person )
act_obj.c:         act( AT_PLAIN, "$p falls from above...", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:         act( AT_PLAIN, "$p falls from above...", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:      if( !xIS_SET( obj->in_room->room_flags, ROOM_NOFLOOR ) && through )
act_obj.c:/*		int dam = (int)9.81*sqrt(fall_count*2/9.81)*obj->weight/2;
act_obj.c:*/ int dam = fall_count * obj->weight / 2;
act_obj.c:         if( obj->in_room->first_person && number_percent(  ) > 15 )
act_obj.c:            for( rch = obj->in_room->first_person; rch; rch = rch->next_in_room, chcnt++ )
act_obj.c:         switch ( obj->item_type )
act_obj.c:               if( ( obj->value[0] - dam ) <= 0 )
act_obj.c:                  if( obj->in_room->first_person )
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:                  obj->value[0] -= dam;
act_obj.c:                  if( obj->in_room->first_person )
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_ROOM );
act_obj.c:                     act( AT_PLAIN, "$p is destroyed by the fall!", obj->in_room->first_person, obj, NULL, TO_CHAR );
act_obj.c:   switch ( obj->item_type )
act_obj.c:         if( ( subject = get_extra_descr( "_subject_", obj->first_extradesc ) ) == NULL )
act_obj.c:         if( obj->first_content )
act_obj.c:            returned_obj = recursive_note_find( obj->first_content, argument );
act_obj.c:   return recursive_note_find( obj->next_content, argument );
act_obj.c:      if( obj->in_obj )
act_obj.c:   return ( obj->action_desc[0] != '\0' ) ? obj->action_desc : "roll$q";
act_obj.c:   for( ed = obj->first_extradesc, count = 1; ed; ed = ed->next, count++ )
act_wiz.c:      return obj->in_room;
act_wiz.c:   if( ( obj = get_obj_world( ch, arg ) ) == NULL || !obj->in_room )
act_wiz.c:   location = obj->in_room;
act_wiz.c:   for( obj = location->first_content; obj; obj = obj->next_content )
act_wiz.c:      one_argument( obj->name, buf );
act_wiz.c:   ch_printf_color( ch, "&cName: &C%s\r\n", obj->name );
act_wiz.c:   ch_printf_color( ch, "&cVnum: &w%d  ", obj->pIndexData->vnum );
act_wiz.c:   ch_printf_color( ch, "&cCount:  &w%d  ", obj->pIndexData->count );
act_wiz.c:   ch_printf_color( ch, "&cGcount: &w%d\r\n", obj->count );
act_wiz.c:   ch_printf_color( ch, "&cSerial#: &w%d  ", obj->serial );
act_wiz.c:   ch_printf_color( ch, "&cTopIdxSerial#: &w%d  ", obj->pIndexData->serial );
act_wiz.c:   ch_printf_color( ch, "&cShort description: &C%s\r\n", obj->short_descr );
act_wiz.c:   ch_printf_color( ch, "&cLong description : &C%s\r\n", obj->description );
act_wiz.c:   if( obj->action_desc && obj->action_desc[0] != '\0' )
act_wiz.c:      ch_printf_color( ch, "&cAction description: &w%s\r\n", obj->action_desc );
act_wiz.c:   if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && obj->owner && obj->owner[0] != '\0' )
act_wiz.c:      ch_printf_color( ch, "&cOwner: &Y%s\r\n", obj->owner );
act_wiz.c:   ch_printf_color( ch, "&cWear flags : &w%s\r\n", flag_string( obj->wear_flags, w_flags ) );
act_wiz.c:   ch_printf_color( ch, "&cExtra flags: &w%s\r\n", ext_flag_string( &obj->extra_flags, o_flags ) );
act_wiz.c:   ch_printf_color( ch, "&cMagic flags: &w%s\r\n", magic_bit_name( obj->magic_flags ) );
act_wiz.c:   ch_printf_color( ch, "&cWeight: &w%d/%d   ", obj->weight, get_obj_weight( obj ) );
act_wiz.c:   ch_printf_color( ch, "&cLayers: &w%d   ", obj->pIndexData->layers );
act_wiz.c:   ch_printf_color( ch, "&cWear_loc: &w%d\r\n", obj->wear_loc );
act_wiz.c:   ch_printf_color( ch, "&cCost: &Y%d  ", obj->cost );
act_wiz.c:   ch_printf_color( ch, "&cRent: &w%d  ", obj->pIndexData->rent );
act_wiz.c:   if( obj->timer > 0 )
act_wiz.c:      ch_printf_color( ch, "&R%d  ", obj->timer );
act_wiz.c:      ch_printf_color( ch, "&w%d  ", obj->timer );
act_wiz.c:   ch_printf_color( ch, "&cLevel: &P%d    ", obj->level );
act_wiz.c:   ch_printf_color( ch, "&cIndex level: &P%d\r\n", obj->pIndexData->level );
act_wiz.c:   ch_printf_color( ch, "&cIn room: &w%d  ", obj->in_room == NULL ? 0 : obj->in_room->vnum );
act_wiz.c:   ch_printf_color( ch, "&cIn object: &w%s  ", obj->in_obj == NULL ? "(none)" : obj->in_obj->short_descr );
act_wiz.c:   ch_printf_color( ch, "&cCarried by: &C%s\r\n", obj->carried_by == NULL ? "(none)" : obj->carried_by->name );
act_wiz.c:                    obj->pIndexData->value[0], obj->pIndexData->value[1],
act_wiz.c:                    obj->pIndexData->value[2], obj->pIndexData->value[3],
act_wiz.c:                    obj->pIndexData->value[4], obj->pIndexData->value[5] );
act_wiz.c:                    obj->value[0], obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5] );
act_wiz.c:   if( obj->item_type == ITEM_ARMOR )
act_wiz.c:      if( obj->pIndexData->armor_type == 0 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 1 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 2 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 3 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 4 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 5 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 6 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 7 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 8 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 9 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 10 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 11 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 12 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 13 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 14 )
act_wiz.c:      else if( obj->pIndexData->armor_type == 15 )
act_wiz.c:         ch_printf( ch, "&cArmor Type: (%d/%d) &W%s\r\n", obj->pIndexData->armor_type, obj->armor_type, buf );
act_wiz.c:   if( obj->pIndexData->first_extradesc )
act_wiz.c:      for( ed = obj->pIndexData->first_extradesc; ed; ed = ed->next )
act_wiz.c:   if( obj->first_extradesc )
act_wiz.c:      for( ed = obj->first_extradesc; ed; ed = ed->next )
act_wiz.c:   for( paf = obj->first_affect; paf; paf = paf->next )
act_wiz.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:      if( obj->in_room && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && !str_cmp( buf2, obj->short_descr ) )
act_wiz.c:                             obj->in_room->area->name,
act_wiz.c:                             obj->in_room->vnum,
act_wiz.c:                             obj->timer < 1 ? "&w" : obj->timer < 5 ? "&R" : obj->timer < 10 ? "&Y" : "&w", obj->timer );
act_wiz.c:            obj->timer = -1;
act_wiz.c:      for( ; obj->in_obj; obj = obj->in_obj )
act_wiz.c:                       obj->pIndexData->vnum, obj_short( obj ), obj->in_obj->pIndexData->vnum, obj->in_obj->short_descr );
act_wiz.c:      snprintf( buf, MAX_STRING_LENGTH, "[%5d] %-28s in ", obj->pIndexData->vnum, obj_short( obj ) );
act_wiz.c:      if( obj->carried_by )
act_wiz.c:                   ( IS_NPC( obj->carried_by ) ? obj->carried_by->pIndexData->vnum : 0 ), PERS( obj->carried_by, ch ) );
act_wiz.c:      else if( obj->in_room )
act_wiz.c:         snprintf( buf + strlen( buf ), ( MAX_STRING_LENGTH - strlen( buf ) ), "room   [%5d] %s\r\n", obj->in_room->vnum,
act_wiz.c:                   obj->in_room->name );
act_wiz.c:      else if( obj->in_obj )
act_wiz.c:         bug( "%s", "do_owhere: obj->in_obj after NULL!" );
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:      if( !nifty_is_name( arg, obj->name ) )
act_wiz.c:      snprintf( buf, MAX_STRING_LENGTH, "(%3d) [%5d] %-28s in ", ++icnt, obj->pIndexData->vnum, obj_short( obj ) );
act_wiz.c:      if( obj->carried_by )
act_wiz.c:                   ( IS_NPC( obj->carried_by ) ? obj->carried_by->pIndexData->vnum : 0 ), PERS( obj->carried_by, ch ) );
act_wiz.c:      else if( obj->in_room )
act_wiz.c:         snprintf( buf + strlen( buf ), ( MAX_STRING_LENGTH - strlen( buf ) ), "room   [%5d] %s\r\n", obj->in_room->vnum,
act_wiz.c:                   obj->in_room->name );
act_wiz.c:      else if( obj->in_obj )
act_wiz.c:                   obj->in_obj->pIndexData->vnum, obj_short( obj->in_obj ) );
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:          && ( obj->pIndexData->vnum == vnum || nifty_is_name( arg1, obj->name ) ) && ( !vch || vch == carried_by( obj ) ) )
act_wiz.c:         if( ( count += obj->count ) >= number )
act_wiz.c:   for( obj = first_object; obj; obj = obj->next )
act_wiz.c:          && ( obj->pIndexData->vnum == vnum || nifty_is_name_prefix( arg1, obj->name ) )
act_wiz.c:         if( ( count += obj->count ) >= number )
act_wiz.c:   if( obj->item_type == ITEM_PORTAL )
act_wiz.c:   if( obj->carried_by )
act_wiz.c:   else if( obj->in_room )
act_wiz.c:   else if( obj->in_obj )
act_wiz.c:   obj->count = quantity;
act_wiz.c:                    pObjIndex->short_descr, pObjIndex->vnum, pObjIndex->name, obj->level, quantity );
act_wiz.c:         obj_next = obj->next_content;
act_wiz.c:      eobj_next = eobj->next;
act_wiz.c:      if( URANGE( pArea->low_o_vnum, eobj->pIndexData->vnum, pArea->hi_o_vnum ) == eobj->pIndexData->vnum
act_wiz.c:          || ( eobj->in_room && eobj->in_room->area == pArea ) )
act_wiz.c:   for( obj = first_object; obj != NULL; obj = obj->next )
act_wiz.c:      if( !can_see_obj( ch, obj ) || !( argi == obj->pIndexData->vnum ) )
act_wiz.c:      for( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj );
act_wiz.c:      if( in_obj->carried_by != NULL )
act_wiz.c:                       obj_counter, obj->level, obj_short( obj ), PERS( in_obj->carried_by, ch ) );
act_wiz.c:                       ( ( in_obj->in_room ) ? in_obj->in_room->vnum : 0 ),
act_wiz.c:                       obj_short( obj ), ( in_obj->in_room == NULL ) ? "somewhere" : in_obj->in_room->name );
act_wiz.c:      STRFREE( obj->owner );
act_wiz.c:      obj->owner = STRALLOC( "" );
act_wiz.c:      xREMOVE_BIT( obj->extra_flags, ITEM_PERSONAL );
act_wiz.c:   STRFREE( obj->owner );
act_wiz.c:   obj->owner = STRALLOC( victim->name );
act_wiz.c:   xSET_BIT( obj->extra_flags, ITEM_PERSONAL );
boards.c:      if( board->board_obj == obj->pIndexData->vnum )
boards.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
build.c:   int vnum = obj->pIndexData->vnum;
build.c:   int vnum = obj->vnum;
build.c:         STRFREE( obj->description );
build.c:         obj->description = copy_buffer( ch );
build.c:               STRFREE( obj->pIndexData->description );
build.c:               obj->pIndexData->description = QUICKLINK( obj->description );
build.c:            do_ostat( ch, obj->name );
build.c:      mudstrlcpy( arg1, obj->name, MAX_INPUT_LENGTH );
build.c:      ch_printf( ch, "Oset mode on. (Editing '%s' vnum %d).\r\n", obj->name, obj->pIndexData->vnum );
build.c:         snprintf( buf, MAX_STRING_LENGTH, "<&COset &W#%d&w> %%i", obj->pIndexData->vnum );
build.c:      STRFREE( obj->name );
build.c:      obj->name = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->name );
build.c:         obj->pIndexData->name = QUICKLINK( obj->name );
build.c:         STRFREE( obj->short_descr );
build.c:         obj->short_descr = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->short_descr );
build.c:         obj->pIndexData->short_descr = QUICKLINK( obj->short_descr );
build.c:         STRFREE( obj->short_descr );
build.c:         obj->short_descr = STRALLOC( arg3 );
build.c:         if( str_infix( "rename", obj->name ) )
build.c:            snprintf( buf, MAX_STRING_LENGTH, "%s %s", obj->name, "rename" );
build.c:            STRFREE( obj->name );
build.c:            obj->name = STRALLOC( buf );
build.c:            STRFREE( obj->description );
build.c:            obj->description = STRALLOC( arg3 );
build.c:            STRFREE( obj->pIndexData->description );
build.c:            obj->pIndexData->description = QUICKLINK( obj->description );
build.c:         STRFREE( obj->description );
build.c:         obj->description = STRALLOC( arg3 );
build.c:      start_editing( ch, obj->description );
build.c:      if( obj->timer )
build.c:      if( obj->item_type == ITEM_PAPER && get_trust( ch ) < LEVEL_IMPLEMENTOR )
build.c:         ed = SetOExtraProto( obj->pIndexData, arg3 );
build.c:         if( DelOExtraProto( obj->pIndexData, arg3 ) )
build.c:      obj->value[0] = value;
build.c:         obj->pIndexData->value[0] = value;
build.c:      obj->value[1] = value;
build.c:         obj->pIndexData->value[1] = value;
build.c:      obj->value[2] = value;
build.c:         obj->pIndexData->value[2] = value;
build.c:         if( obj->item_type == ITEM_WEAPON && value != 0 )
build.c:            obj->value[2] = obj->pIndexData->value[1] * obj->pIndexData->value[2];
build.c:      obj->value[3] = value;
build.c:         obj->pIndexData->value[3] = value;
build.c:      obj->value[4] = value;
build.c:         obj->pIndexData->value[4] = value;
build.c:      obj->value[5] = value;
build.c:         obj->pIndexData->value[5] = value;
build.c:      obj->item_type = ( short )value;
build.c:         obj->pIndexData->item_type = obj->item_type;
build.c:               xTOGGLE_BIT( obj->extra_flags, value );
build.c:                  obj->pIndexData->extra_flags = obj->extra_flags;
build.c:         obj->pIndexData->extra_flags = obj->extra_flags;
build.c:            TOGGLE_BIT( obj->wear_flags, 1 << value );
build.c:         obj->pIndexData->wear_flags = obj->wear_flags;
build.c:      obj->level = value;
build.c:         obj->pIndexData->level = value;
build.c:      if( obj->item_type != ITEM_ARMOR )
build.c:      obj->armor_type = value;
build.c:         obj->pIndexData->armor_type = value;
build.c:      obj->weight = value;
build.c:         obj->pIndexData->weight = value;
build.c:      obj->cost = value;
build.c:         obj->pIndexData->cost = value;
build.c:         obj->pIndexData->rent = value;
build.c:         obj->pIndexData->layers = value;
build.c:      obj->timer = value;
build.c:      STRFREE( obj->action_desc );
build.c:      obj->action_desc = STRALLOC( arg3 );
build.c:         STRFREE( obj->pIndexData->action_desc );
build.c:         obj->pIndexData->action_desc = QUICKLINK( obj->action_desc );
build.c:                  if( eq->pIndexData == obj->pIndexData && eq->wear_loc != WEAR_NONE )
build.c:         LINK( paf, obj->pIndexData->first_affect, obj->pIndexData->last_affect, next, prev );
build.c:         LINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c:         pObjIndex = obj->pIndexData;
build.c:         for( paf = obj->first_affect; paf; paf = paf->next )
build.c:               UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
build.c:   switch ( obj->item_type )
build.c:      obj->value[tmp] = value;
build.c:         obj->pIndexData->value[tmp] = value;
build.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
build.c:      LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:   for( rmed = obj->first_extradesc; rmed; rmed = rmed->next )
build.c:   UNLINK( rmed, obj->first_extradesc, obj->last_extradesc, next, prev );
build.c:         obj_next = obj->next_content;
build.c:         if( xIS_SET( obj->extra_flags, ITEM_PROTOTYPE ) )
build.c:            obj_next = obj->next_content;
build.c:      pager_printf( ch, "%5d) %-20s (%s)\r\n", vnum, obj->name, obj->short_descr );
build.c:   mprog = obj->pIndexData->mudprogs;
build.c:            xCLEAR_BITS( obj->pIndexData->progtypes );
build.c:               xSET_BIT( obj->pIndexData->progtypes, mprg->type );
build.c:         mprg_next = obj->pIndexData->mudprogs;
build.c:         obj->pIndexData->mudprogs = mprg_next->next;
build.c:            xREMOVE_BIT( obj->pIndexData->progtypes, mptype );
build.c:         xSET_BIT( obj->pIndexData->progtypes, mptype );
build.c:         obj->pIndexData->mudprogs = mprg;
build.c:            xSET_BIT( obj->pIndexData->progtypes, mptype );
build.c:         obj->pIndexData->mudprogs = mprg;
build.c:      xSET_BIT( obj->pIndexData->progtypes, mptype );
build.c:       && ( obj->vnum < ch->pcdata->area->low_o_vnum || obj->vnum > ch->pcdata->area->hi_o_vnum ) )
clans.c:         tobj_next = tobj->next_content;
clans.c:   xSET_BIT( obj->extra_flags, ITEM_CLANOBJECT );
comm.c:   if( !str_prefix( "a ", obj->short_descr ) )
comm.c:      return obj->short_descr + 2;
comm.c:   if( !str_prefix( "an ", obj->short_descr ) )
comm.c:      return obj->short_descr + 3;
comm.c:   if( !str_prefix( "the ", obj->short_descr ) )
comm.c:      return obj->short_descr + 4;
comm.c:   if( !str_prefix( "some ", obj->short_descr ) )
comm.c:      return obj->short_descr + 5;
comm.c:   return obj->short_descr;
comm.c:   if( obj->count > 1 )
comm.c:      snprintf( buf, MAX_STRING_LENGTH, "%s (%d)", obj->short_descr, obj->count );
comm.c:   return obj->short_descr;
comm.c:      for( to_obj = to->in_room->first_content; to_obj; to_obj = to_obj->next_content )
comm.c:         if( HAS_PROG( to_obj->pIndexData, ACT_PROG ) )
db.c:   obj->pIndexData = pObjIndex;
db.c:   obj->in_room = NULL;
db.c:   obj->level = level;
db.c:   obj->wear_loc = -1;
db.c:   obj->count = 1;
db.c:   obj->serial = obj->pIndexData->serial = cur_obj_serial;
db.c:   obj->name = QUICKLINK( pObjIndex->name );
db.c:   obj->short_descr = QUICKLINK( pObjIndex->short_descr );
db.c:   obj->description = QUICKLINK( pObjIndex->description );
db.c:   obj->action_desc = QUICKLINK( pObjIndex->action_desc );
db.c:   obj->owner = STRALLOC( "" );
db.c:   obj->item_type = pObjIndex->item_type;
db.c:   obj->extra_flags = pObjIndex->extra_flags;
db.c:   obj->wear_flags = pObjIndex->wear_flags;
db.c:   obj->value[0] = pObjIndex->value[0];
db.c:   obj->value[1] = pObjIndex->value[1];
db.c:   obj->value[2] = pObjIndex->value[2];
db.c:   obj->value[3] = pObjIndex->value[3];
db.c:   obj->value[4] = pObjIndex->value[4];
db.c:   obj->value[5] = pObjIndex->value[5];
db.c:   obj->weight = pObjIndex->weight;
db.c:    * obj->cost     = number_fuzzy( 10 )
db.c:   switch ( obj->item_type )
db.c:         bug( "------------------------>  %d ", obj->item_type );
db.c:         if( obj->value[4] )
db.c:            obj->timer = obj->value[4];
db.c:            obj->timer = obj->value[1];
db.c:         obj->value[3] = number_fuzzy( obj->value[3] );
db.c:         obj->value[0] = number_fuzzy( obj->value[0] );
db.c:         obj->value[0] = number_fuzzy( obj->value[0] );
db.c:         obj->value[1] = number_fuzzy( obj->value[1] );
db.c:         obj->value[2] = obj->value[1];
db.c:         if( obj->value[1] && obj->value[2] )
db.c:            obj->value[2] *= obj->value[1];
db.c:            obj->value[1] = number_fuzzy( number_fuzzy( 1 * level / 4 + 2 ) );
db.c:            obj->value[2] = number_fuzzy( number_fuzzy( 3 * level / 4 + 6 ) );
db.c:         if( obj->value[0] == 0 )
db.c:            obj->value[0] = INIT_WEAPON_CONDITION;
db.c:         if( obj->value[0] == 0 )
db.c:            obj->value[0] = number_fuzzy( level / 4 + 2 );
db.c:         if( obj->value[1] == 0 )
db.c:            obj->value[1] = obj->value[0];
db.c:        obj->armor_type = pObjIndex->armor_type;
db.c:         obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
db.c:         obj->value[0] = obj->cost;
db.c:         if( obj->value[0] == 0 )
db.c:            obj->value[0] = 1;
db.c:            xSET_BIT( obj->progtypes, mprg->type );
db.c:            mprg->next = obj->mudprogs;
db.c:            obj->mudprogs = mprg;
db.c:         bug( "%s: vnum %d MUDPROG char", __func__, obj->vnum );
db.c:      mprg->next = obj->mudprogs;
db.c:      obj->mudprogs = mprg;
db.c:            bug( "%s: vnum %d MUDPROG type.", __func__, obj->vnum );
db.c:            xSET_BIT( obj->progtypes, mprg->type );
db.c:   while( ( ed = obj->first_extradesc ) != NULL )
db.c:      obj->first_extradesc = ed->next;
db.c:   while( ( af = obj->first_affect ) != NULL )
db.c:      obj->first_affect = af->next;
db.c:   while( ( mp = obj->mudprogs ) != NULL )
db.c:      obj->mudprogs = mp->next;
db.c:   STRFREE( obj->name );
db.c:   STRFREE( obj->short_descr );
db.c:   STRFREE( obj->description );
db.c:   STRFREE( obj->action_desc );
db.c:   hash = obj->vnum % MAX_KEY_HASH;
db.c:      obj_index_hash[hash] = obj->next;
db.c:         prev->next = obj->next;
db.c:         bug( "%s: object %d not in hash bucket %d.", __func__, obj->vnum, hash );
deity.c:      for( obj = first_object; obj; obj = obj->next )
deity.c:         if( obj->in_room && !str_cmp( buf2, obj->short_descr ) && ( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC ) )
deity.c:            if( IS_PKILL( ch ) && obj->timer > 19 )
deity.c:            if( xIS_SET( obj->in_room->room_flags, ROOM_NOSUPPLICATE ) )
deity.c:            xREMOVE_BIT( obj->extra_flags, ITEM_BURIED );
deity.c:      STRFREE( obj->name );
deity.c:      obj->name = STRALLOC( buf );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, ch->pcdata->deity->name );
deity.c:      STRFREE( obj->short_descr );
deity.c:      obj->short_descr = STRALLOC( buf );
deity.c:      snprintf( buf, MAX_STRING_LENGTH, obj->description, ch->pcdata->deity->name );
deity.c:      STRFREE( obj->description );
deity.c:      obj->description = STRALLOC( buf );
deity.c:      LINK( paf, obj->first_affect, obj->last_affect, next, prev );
fight.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
fight.c:   for( paf = obj->first_affect; paf; paf = paf->next )
fight.c:      obj->timer = number_range( 4, 7 );
fight.c:         obj->value[3] = 10;
fight.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, name );
fight.c:      STRFREE( obj->short_descr );
fight.c:      obj->short_descr = STRALLOC( buf );
fight.c:      snprintf( buf, MAX_STRING_LENGTH, obj->description, name );
fight.c:      STRFREE( obj->description );
fight.c:      obj->description = STRALLOC( buf );
fight.c:         obj_next = obj->next_content;
fight.c:         if( obj->wear_loc == WEAR_NONE )
fight.c:            attack = obj->short_descr;
handler.c:   if( ( tp == TR_OBJ_ROOM_FORW || tp == TR_OBJ_ROOM_BACK ) && !obj->in_room )
handler.c:   if( ( tp == TR_OBJ_CHAR_FORW || tp == TR_OBJ_CHAR_BACK ) && !obj->carried_by )
handler.c:   if( ( tp == TR_OBJ_OBJ_FORW || tp == TR_OBJ_OBJ_BACK ) && !obj->in_obj )
handler.c:         ground_zero = obj->in_room;
handler.c:         first = ptr = obj->in_room->first_content;
handler.c:         ground_zero = obj->in_room;
handler.c:         first = ptr = obj->in_room->last_content;
handler.c:         ground_zero = obj->carried_by;
handler.c:         first = ptr = obj->carried_by->first_carrying;
handler.c:         ground_zero = obj->carried_by;
handler.c:         first = ptr = obj->carried_by->last_carrying;
handler.c:         ground_zero = obj->in_obj;
handler.c:         first = ptr = obj->in_obj->first_content;
handler.c:         ground_zero = obj->in_obj;
handler.c:         first = ptr = obj->in_obj->last_content;
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->wear_loc != WEAR_NONE )
handler.c:         for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:         for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:       && obj->item_type == ITEM_LIGHT
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room->light > 0 )
handler.c:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) )
handler.c:   int wear_loc = obj->wear_loc;
handler.c:   EXT_BV extra_flags = obj->extra_flags;
handler.c:         obj->carried_by = ch;
handler.c:         obj->in_room = NULL;
handler.c:         obj->in_obj = NULL;
handler.c:            if( obj->level > otmp->level )
handler.c:            else if( obj->level == otmp->level && strcmp( obj->short_descr, otmp->short_descr ) < 0 )
handler.c:         obj->carried_by = ch;
handler.c:         obj->in_room = NULL;
handler.c:         obj->in_obj = NULL;
handler.c:   if( ( ch = obj->carried_by ) == NULL )
handler.c:   if( obj->wear_loc != WEAR_NONE )
handler.c:   if( !obj->carried_by )
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:   if( obj->item_type != ITEM_ARMOR )
handler.c:         return 3 * obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return 2 * obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:         return obj->value[0];
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->wear_loc == iWear )
handler.c:         if( !obj->pIndexData->layers )
handler.c:         else if( !maxobj || obj->pIndexData->layers > maxobj->pIndexData->layers )
handler.c:   if( obj->carried_by != ch )
handler.c:   if( ( otmp = get_eq_char( ch, iWear ) ) != NULL && ( !otmp->pIndexData->layers || !obj->pIndexData->layers ) )
handler.c:      if( obj->carried_by )
handler.c:   obj->wear_loc = iWear;
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:       && obj->item_type == ITEM_LIGHT && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room )
handler.c:   if( obj->wear_loc == WEAR_NONE )
handler.c:   if( obj->wear_loc == WEAR_WIELD
handler.c:      tobj->wear_loc = WEAR_WIELD;
handler.c:   ch->armor += apply_ac( obj, obj->wear_loc );
handler.c:   obj->wear_loc = -1;
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   if( obj->carried_by )
handler.c:      for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:   if( !obj->carried_by )
handler.c:   if( obj->item_type == ITEM_LIGHT
handler.c:       && ( obj->value[2] != 0 || IS_SET( obj->value[3], PIPE_LIT ) ) && ch->in_room && ch->in_room->light > 0 )
handler.c:   if( ( in_room = obj->in_room ) == NULL )
handler.c:   for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:      empty_obj( obj, NULL, obj->in_room );
handler.c:   if( obj->item_type == ITEM_FIRE )
handler.c:      obj->in_room->light -= obj->count;
handler.c:   obj->in_room->weight -= get_obj_weight( obj );
handler.c:   obj->carried_by = NULL;
handler.c:   obj->in_obj = NULL;
handler.c:   obj->in_room = NULL;
handler.c:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling < 1 )
handler.c:      write_corpses( NULL, obj->short_descr + 14, obj );
handler.c:   short count = obj->count;
handler.c:   short item_type = obj->item_type;
handler.c:   for( paf = obj->first_affect; paf; paf = paf->next )
handler.c:   for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
handler.c:   obj->in_room = pRoomIndex;
handler.c:   obj->carried_by = NULL;
handler.c:   obj->in_obj = NULL;
handler.c:   obj->room_vnum = pRoomIndex->vnum;  /* hotboot tracker */
handler.c:   if( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && falling < 1 )
handler.c:      write_corpses( NULL, obj->short_descr + 14, NULL );
handler.c:   if( obj->in_obj )
handler.c:      return carried_by( obj->in_obj );
handler.c:   return obj->carried_by;
handler.c:      bug( "Obj_to_obj: trying to put object inside itself: vnum %d", obj->pIndexData->vnum );
handler.c:   obj->in_obj = obj_to;
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:   if( ( obj_from = obj->in_obj ) == NULL )
handler.c:   if( IS_OBJ_STAT( obj, ITEM_COVERING ) && obj->first_content )
handler.c:      empty_obj( obj, obj->in_obj, NULL );
handler.c:   obj->in_obj = NULL;
handler.c:   obj->in_room = NULL;
handler.c:   obj->carried_by = NULL;
handler.c:      bug( "%s: obj %d already extracted!", __func__, obj->pIndexData->vnum );
handler.c:   if( obj->item_type == ITEM_PORTAL )
handler.c:   if( obj->carried_by )
handler.c:   else if( obj->in_room )
handler.c:   else if( obj->in_obj )
handler.c:   while( ( obj_content = obj->last_content ) != NULL )
handler.c:      for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:      obj->first_affect = obj->last_affect = NULL;
handler.c:      for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:      obj->first_extradesc = obj->last_extradesc = NULL;
handler.c:   obj->pIndexData->count -= obj->count;
handler.c:   numobjsloaded -= obj->count;
handler.c:   if( obj->serial == cur_obj )
handler.c:      obj_prev = obj->prev_content;
handler.c:         if( obj->wear_loc != WEAR_NONE )
handler.c:   for( obj = list; obj; obj = obj->next_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = list; obj; obj = obj->next_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = list; obj; obj = obj->prev_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = list; obj; obj = obj->prev_content )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( can_see_obj( ch, obj ) && obj->pIndexData->vnum == vnum )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc == WEAR_NONE
handler.c:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc != WEAR_NONE
handler.c:          && can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || obj->pIndexData->vnum == vnum ) )
handler.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
handler.c:      if( obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:   for( obj = first_object; obj; obj = obj->next )
handler.c:      if( can_see_obj( ch, obj ) && ( nifty_is_name( arg, obj->name ) || vnum == obj->pIndexData->vnum ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   for( obj = first_object; obj; obj = obj->next )
handler.c:      if( can_see_obj( ch, obj ) && nifty_is_name_prefix( arg, obj->name ) )
handler.c:         if( ( count += obj->count ) >= number )
handler.c:   return obj->count;
handler.c:   if( obj->item_type == ITEM_CONTAINER && IS_OBJ_STAT( obj, ITEM_MAGIC ) )
handler.c:   if( obj->in_obj )
handler.c:      return in_magic_container( obj->in_obj );
handler.c:   weight = obj->count * obj->weight;
handler.c:   if( obj->item_type != ITEM_CONTAINER || !IS_OBJ_STAT( obj, ITEM_MAGIC ) )
handler.c:      for( obj = obj->first_content; obj; obj = obj->next_content )
handler.c:   weight = obj->count * obj->weight;
handler.c:   for( obj = obj->first_content; obj; obj = obj->next_content )
handler.c:   if( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
handler.c:   if( obj->item_type < 1 || obj->item_type > MAX_ITEM_TYPE )
handler.c:      bug( "Item_type_name: unknown type %d.", obj->item_type );
handler.c:   return o_types[obj->item_type];
handler.c:   typ = obj->value[1];
handler.c:   lev = obj->value[2];
handler.c:   dam = number_range( obj->value[2], obj->value[2] * 2 );
handler.c:   --obj->value[0];
handler.c:   if( obj->value[0] <= 0 )
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:   if( !obj->first_content )
handler.c:   for( check = obj->first_content; check; check = check->next_content )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->item_type == type )
handler.c:   STRFREE( obj->name );
handler.c:   STRFREE( obj->short_descr );
handler.c:   STRFREE( obj->description );
handler.c:   STRFREE( obj->action_desc );
handler.c:   obj->item_type = 0;
handler.c:   xCLEAR_BITS( obj->extra_flags );
handler.c:   obj->wear_flags = 0;
handler.c:   obj->count = 0;
handler.c:   obj->weight = 0;
handler.c:   obj->cost = 0;
handler.c:   obj->value[0] = 0;
handler.c:   obj->value[1] = 0;
handler.c:   obj->value[2] = 0;
handler.c:   obj->value[3] = 0;
handler.c:   obj->value[4] = 0;
handler.c:   obj->value[5] = 0;
handler.c:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:   obj->first_affect = NULL;
handler.c:   obj->last_affect = NULL;
handler.c:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:   obj->first_extradesc = NULL;
handler.c:   obj->last_extradesc = NULL;
handler.c:   for( mprog = obj->mudprogs; mprog; mprog = mprog_next )
handler.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
handler.c:      if( obj->wear_loc == WEAR_NONE )
handler.c:      if( !xIS_SET( obj->extra_flags, ITEM_MAGIC ) )
handler.c:   cur_obj = obj->serial;
handler.c:   if( obj->serial == cur_obj && cur_obj_extracted )
handler.c:   obj->next = extracted_obj_queue;
handler.c:   for( mpact = obj->mpact; mpact; mpact = mpact_next )
handler.c:   for( paf = obj->first_affect; paf; paf = paf_next )
handler.c:   obj->first_affect = obj->last_affect = NULL;
handler.c:   for( ed = obj->first_extradesc; ed; ed = ed_next )
handler.c:   obj->first_extradesc = obj->last_extradesc = NULL;
handler.c:   STRFREE( obj->name );
handler.c:   STRFREE( obj->description );
handler.c:   STRFREE( obj->short_descr );
handler.c:   STRFREE( obj->action_desc );
handler.c:   STRFREE( obj->owner );
handler.c:   clone->pIndexData = obj->pIndexData;
handler.c:   clone->name = QUICKLINK( obj->name );
handler.c:   clone->short_descr = QUICKLINK( obj->short_descr );
handler.c:   clone->description = QUICKLINK( obj->description );
handler.c:   clone->action_desc = QUICKLINK( obj->action_desc );
handler.c:   clone->owner = QUICKLINK( obj->owner );
handler.c:   clone->item_type = obj->item_type;
handler.c:   clone->extra_flags = obj->extra_flags;
handler.c:   clone->magic_flags = obj->magic_flags;
handler.c:   clone->wear_flags = obj->wear_flags;
handler.c:   clone->wear_loc = obj->wear_loc;
handler.c:   clone->weight = obj->weight;
handler.c:   clone->cost = obj->cost;
handler.c:   clone->level = obj->level;
handler.c:   clone->timer = obj->timer;
handler.c:   clone->value[0] = obj->value[0];
handler.c:   clone->value[1] = obj->value[1];
handler.c:   clone->value[2] = obj->value[2];
handler.c:   clone->value[3] = obj->value[3];
handler.c:   clone->value[4] = obj->value[4];
handler.c:   clone->value[5] = obj->value[5];
handler.c:   ++obj->pIndexData->count;
handler.c: * This code, along with clone_object, obj->count, and special support
handler.c:   int count = obj->count;
handler.c:   --obj->pIndexData->count;  /* since clone_object() ups this value */
handler.c:   rest->count = obj->count - num;
handler.c:   obj->count = num;
handler.c:   if( obj->carried_by )
handler.c:      LINK( rest, obj->carried_by->first_carrying, obj->carried_by->last_carrying, next_content, prev_content );
handler.c:      rest->carried_by = obj->carried_by;
handler.c:   else if( obj->in_room )
handler.c:      LINK( rest, obj->in_room->first_content, obj->in_room->last_content, next_content, prev_content );
handler.c:      rest->in_room = obj->in_room;
handler.c:   else if( obj->in_obj )
handler.c:      LINK( rest, obj->in_obj->first_content, obj->in_obj->last_content, next_content, prev_content );
handler.c:      rest->in_obj = obj->in_obj;
handler.c:   ch = obj->carried_by;
handler.c:   if( destobj || ( !destroom && !ch && ( destobj = obj->in_obj ) != NULL ) )
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:         if( destobj->item_type == ITEM_KEYRING && otmp->item_type != ITEM_KEY )
handler.c:         if( destobj->item_type == ITEM_QUIVER && otmp->item_type != ITEM_PROJECTILE )
handler.c:         if( ( destobj->item_type == ITEM_CONTAINER || destobj->item_type == ITEM_KEYRING
handler.c:               || destobj->item_type == ITEM_QUIVER )
handler.c:             && ( get_real_obj_weight( otmp ) + get_real_obj_weight( destobj ) > destobj->value[0]
handler.c:                  || ( destobj->in_room
handler.c:                       && destobj->in_room->max_weight
handler.c:                       && destobj->in_room->max_weight < get_real_obj_weight( otmp ) + destobj->in_room->weight ) ) )
handler.c:   if( destroom || ( !ch && ( destroom = obj->in_room ) != NULL ) )
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:               otmp_next = obj->first_content;
handler.c:      for( otmp = obj->first_content; otmp; otmp = otmp_next )
handler.c:   bug( "%s: could not determine a destination for vnum %d", __func__, obj->pIndexData->vnum );
hotboot.c:         tobj_next = tobj->next_content;
hotboot.c:            supermob->map = tobj->map;
hotboot.c:            supermob->x = tobj->x;
hotboot.c:            supermob->y = tobj->y;
house.c:            name = str_dup( obj->short_descr );
house.c:         newacc->price = obj->cost;
house.c:         ch_printf_color( ch, "&C&gName: &G%s\r\n", obj->short_descr );
house.c:            ch_printf_color( ch, "&gVnum: &G%d", obj->vnum );
house.c:         ch_printf_color( ch, "&C&gType: &G%s\r\n", o_types[obj->item_type] );
house.c:         ch_printf_color( ch, "&C&gFlags: &G%s\r\n", ext_flag_string( &obj->extra_flags, o_flags ) );
house.c:         ch_printf_color( ch, "&C&gMagical Flags: &G%s\r\n", magic_bit_name( obj->magic_flags ) );
house.c:         ch_printf_color( ch, "&C&gWeight: &G%d\r\n", obj->weight );
liquids.c:         pager_printf( ch, "&wMix &G%s&w (%d)\r\n", obj->name, mix->data[0] );
liquids.c:               ch_printf( ch, "Mixture object set to %d - %s\r\n", i, obj->name );
liquids.c:      for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
liquids.c:         if( ( obj->item_type == ITEM_FOUNTAIN ) || ( obj->item_type == ITEM_BLOOD ) || ( obj->item_type == ITEM_PUDDLE ) )
liquids.c:   if( obj->count > 1 && obj->item_type != ITEM_FOUNTAIN )
liquids.c:   switch ( obj->item_type )
liquids.c:         if( obj->carried_by == ch )
liquids.c:            if( obj->timer > 0   /* if timer, must be spilled blood */
liquids.c:                  if( obj->value[1] <= 1 )
liquids.c:               if( --obj->value[1] <= 0 )
liquids.c:                  if( obj->serial == cur_obj )
liquids.c:         if( obj->carried_by == ch )
liquids.c:            snprintf( buf, MAX_STRING_LENGTH, "quaff %s", obj->name );
liquids.c:         if( obj->value[1] <= 0 )
liquids.c:            obj->value[1] = MAX_COND_VALUE;
liquids.c:         if( ( liq = get_liq_vnum( obj->value[2] ) ) == NULL )
liquids.c:            bug( "%s: bad liquid number %d.", __func__, obj->value[2] );
liquids.c:         if( !IS_NPC( ch ) && obj->value[2] != 0 )
liquids.c:         else if( !IS_NPC( ch ) && obj->value[2] == 0 )
liquids.c:         if( obj->value[1] <= 0 )
liquids.c:         if( ( liq = get_liq_vnum( obj->value[2] ) ) == NULL )
liquids.c:            bug( "%s: bad liquid number %d.", __func__, obj->value[2] );
liquids.c:            af.duration = obj->value[3];
liquids.c:         obj->value[1] -= amount;
liquids.c:         if( obj->value[1] <= 0 )   /* Come now, what good is a drink container that vanishes?? */
liquids.c:            obj->value[1] = 0;   /* Prevents negative values - Samson */
liquids.c:         if( obj->value[1] <= 0 )
liquids.c:            bug( "%s: empty puddle %d.", __func__, obj->in_room->vnum ); 
liquids.c:         if( ( liq = get_liq_vnum( obj->value[2] ) ) == NULL )
liquids.c:            bug( "%s: bad liquid number %d.", __func__, obj->value[2] );
liquids.c:            af.duration = obj->value[3];
liquids.c:         obj->value[1] -= amount;
liquids.c:         if( obj->value[1] <= 0 )
liquids.c:            if( cur_obj == obj->serial )
liquids.c:      dest_item = obj->item_type;
liquids.c:      if( IS_SET( obj->value[1], CONT_CLOSED ) )
liquids.c:         act( AT_PLAIN, "The $d is closed.", ch, NULL, obj->name, TO_CHAR );
liquids.c:      if( get_real_obj_weight( obj ) / obj->count >= obj->value[0] )
liquids.c:      if( diff < 1 || obj->value[1] >= obj->value[0] )
liquids.c:   if( dest_item == ITEM_PIPE && IS_SET( obj->value[3], PIPE_FULLOFASH ) )
liquids.c:                || ( get_real_obj_weight( source ) + get_real_obj_weight( obj ) / obj->count ) > obj->value[0] )
liquids.c:                || ( get_real_obj_weight( source ) + get_real_obj_weight( obj ) / obj->count ) > obj->value[0] )
liquids.c:                   || ( get_real_obj_weight( source ) + get_real_obj_weight( obj ) / obj->count ) > obj->value[0] )
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != 0 )
liquids.c:         obj->value[2] = 0;
liquids.c:         obj->value[1] = obj->value[0];
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != 13 )
liquids.c:         obj->value[2] = 13;
liquids.c:         obj->value[1] += diff;
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
liquids.c:         obj->value[2] = source->value[2];
liquids.c:         obj->value[1] += diff;
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
liquids.c:         obj->value[2] = source->value[2];
liquids.c:         obj->value[1] += diff;
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
liquids.c:         obj->value[2] = source->value[2];
liquids.c:         obj->value[1] += diff;
liquids.c:         if( obj->value[1] != 0 && obj->value[2] != source->value[2] )
liquids.c:         obj->value[2] = source->value[2];
liquids.c:         obj->value[1] += diff;
liquids.c:   if( obj->count > 1 )
liquids.c:   switch ( obj->item_type )
liquids.c:         REMOVE_BIT( obj->value[3], PIPE_FULLOFASH );
liquids.c:         REMOVE_BIT( obj->value[3], PIPE_LIT );
liquids.c:         obj->value[1] = 0;
liquids.c:         if( obj->value[1] < 1 )
liquids.c:         obj->value[1] = 0;
liquids.c:         if( IS_SET( obj->value[1], CONT_CLOSED ) )
liquids.c:            act( AT_PLAIN, "The $d is closed.", ch, NULL, obj->name, TO_CHAR );
liquids.c:         if( !obj->first_content )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( obj->item_type == value )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( obj->pIndexData->vnum == value )
magic.c:            for( obj = ch->first_carrying; obj; obj = obj->next_content )
magic.c:               if( nifty_is_name( check, obj->name ) )
magic.c:            if( obj->value[val] <= 0 )
magic.c:            else if( --obj->value[val] == 0 )
magic.c:            int count = obj->count;
magic.c:            obj->count = 1;
magic.c:            obj->count = count;
magic.c:            target_name = obj->name;
magic.c:   if( obj->item_type != ITEM_DRINK_CON )
magic.c:   if( ( !liq || liq->vnum != obj->value[2] ) && obj->value[1] != 0 )
magic.c:   water = UMIN( level * ( getPrecip( cell ) >= 0 ? 4 : 2 ), obj->value[0] - obj->value[1] );
magic.c:      obj->value[2] = liq->vnum;
magic.c:      obj->value[1] += water;
magic.c:      if( !is_name( "water", obj->name ) )
magic.c:         snprintf( buf, MAX_STRING_LENGTH, "%s water", obj->name );
magic.c:         STRFREE( obj->name );
magic.c:         obj->name = STRALLOC( buf );
magic.c:   if( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD || obj->item_type == ITEM_COOK )
magic.c:      if( obj->item_type == ITEM_COOK && obj->value[2] == 0 )
magic.c:      else if( obj->value[3] != 0 )
magic.c:   if( obj->item_type != ITEM_WEAPON || IS_OBJ_STAT( obj, ITEM_MAGIC ) || IS_OBJ_STAT( obj, ITEM_ENCHANTED ) || obj->first_affect )
magic.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
magic.c:   LINK( paf, obj->first_affect, obj->last_affect, next, prev );
magic.c:   xSET_BIT( obj->extra_flags, ITEM_ENCHANTED );
magic.c:      xSET_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:      xSET_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:      xSET_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:      xSET_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:   if( obj->item_type != ITEM_WEAPON )
magic.c:   if( !IS_OBJ_STAT( obj, ITEM_ENCHANTED ) || !obj->first_affect )
magic.c:   for( paf = obj->first_affect; paf; paf = paf_next )
magic.c:         UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
magic.c:      xREMOVE_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:      xREMOVE_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:      xREMOVE_BIT( obj->extra_flags, ITEM_ANTI_GOOD );
magic.c:      xREMOVE_BIT( obj->extra_flags, ITEM_ANTI_EVIL );
magic.c:                 obj->short_descr, aoran( item_type_name( obj ) ) );
magic.c:      if( obj->item_type != ITEM_LIGHT && obj->wear_flags - 1 > 0 )
magic.c:         ch_printf( ch, ", with wear location:  %s\r\n", flag_string( obj->wear_flags, w_flags ) );
magic.c:                 extra_bit_name( &obj->extra_flags ),
magic.c:                 obj->weight, obj->cost, obj->level );
magic.c:      if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && obj->owner[0] != '\0' )
magic.c:         ch_printf( ch, "&cOwner: &Y%s\r\n", obj->owner );
magic.c:      switch ( obj->item_type )
magic.c:            ch_printf( ch, "%s appears to be %s.\r\n", capitalize( obj->short_descr ),
magic.c:                       obj->value[0] < 76 ? "of a small capacity" :
magic.c:                       obj->value[0] < 150 ? "of a small to medium capacity" :
magic.c:                       obj->value[0] < 300 ? "of a medium capacity" :
magic.c:                       obj->value[0] < 550 ? "of a medium to large capacity" :
magic.c:                       obj->value[0] < 751 ? "of a large capacity" : "of a giant capacity" );
magic.c:            ch_printf( ch, "Level %d spells of:", obj->value[0] );
magic.c:            if( obj->value[1] >= 0 && ( sktmp = get_skilltype( obj->value[1] ) ) != NULL )
magic.c:            if( obj->value[2] >= 0 && ( sktmp = get_skilltype( obj->value[2] ) ) != NULL )
magic.c:            if( obj->value[3] >= 0 && ( sktmp = get_skilltype( obj->value[3] ) ) != NULL )
magic.c:            ch_printf( ch, "Has %d(%d) applications of level %d", obj->value[1], obj->value[2], obj->value[0] );
magic.c:            if( obj->value[4] >= 0 && ( sktmp = get_skilltype( obj->value[4] ) ) != NULL )
magic.c:            if( obj->value[5] >= 0 && ( sktmp = get_skilltype( obj->value[5] ) ) != NULL )
magic.c:            ch_printf( ch, "Has %d(%d) charges of level %d", obj->value[1], obj->value[2], obj->value[0] );
magic.c:            if( obj->value[3] >= 0 && ( sktmp = get_skilltype( obj->value[3] ) ) != NULL )
magic.c:                       obj->value[1], obj->value[2],
magic.c:                       ( obj->value[1] + obj->value[2] ) / 2,
magic.c:            ch_printf( ch, "Armor class is %d.\r\n", obj->value[0] );
magic.c:      for( paf = obj->pIndexData->first_affect; paf; paf = paf->next )
magic.c:      for( paf = obj->first_affect; paf; paf = paf->next )
magic.c:         xSET_BIT( obj->extra_flags, ITEM_INVIS );
magic.c:   for( obj = first_object; obj; obj = obj->next )
magic.c:      if( !can_see_obj( ch, obj ) || !nifty_is_name( target_name, obj->name ) )
magic.c:      for( cnt = 0, in_obj = obj; in_obj->in_obj && cnt < 100; in_obj = in_obj->in_obj, ++cnt )
magic.c:              obj->pIndexData->vnum, obj->short_descr, MAX_NEST );
magic.c:      if( in_obj->carried_by )
magic.c:         if( IS_IMMORTAL( in_obj->carried_by )
magic.c:             && !IS_NPC( in_obj->carried_by )
magic.c:             && ( get_trust( ch ) < in_obj->carried_by->pcdata->wizinvis )
magic.c:             && xIS_SET( in_obj->carried_by->act, PLR_WIZINVIS ) )
magic.c:         snprintf( buf, MAX_INPUT_LENGTH, "%s carried by %s.\r\n", obj_short( obj ), PERS( in_obj->carried_by, ch ) );
magic.c:                   in_obj->in_room == NULL ? "somewhere" : in_obj->in_room->name );
magic.c:      for( obj = victim->first_carrying; obj; obj = obj->next_content )
magic.c:         if( !obj->in_obj && ( IS_OBJ_STAT( obj, ITEM_NOREMOVE ) || IS_OBJ_STAT( obj, ITEM_NODROP ) ) )
magic.c:               xREMOVE_BIT( obj->extra_flags, ITEM_NOREMOVE );
magic.c:               xREMOVE_BIT( obj->extra_flags, ITEM_NODROP );
magic.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
magic.c:      if( can_see_obj( ch, obj ) && nifty_is_name( target_name, obj->name ) )
magic.c:                     victim->armor += apply_ac( obj_lose, iWear );   /* <-- victim is LOSING the benefit of obj->value[0] */
magic.c:               }  /* obj->value[0] so we need to SUBTRACT to his AC */
magic.c:      obj_next = obj->next_content;
magic.c:      if( obj->item_type == ITEM_PORTAL )
magic.c:         obj->item_type = ITEM_TRASH;
magic.c:   if( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND )
magic.c:      if( obj->value[2] == obj->value[1] || obj->value[1] > ( obj->pIndexData->value[1] * 4 ) )
magic.c:         if( damage( ch, ch, obj->level * 2, TYPE_UNDEFINED ) == rCHAR_DIED || char_died( ch ) )
magic.c:         obj->value[1] *= 2;
magic.c:         obj->value[2] = obj->value[1];
magic.c:         obj->value[2] = obj->value[1];
magic.c:         --obj->value[1];
magic.c:         obj->value[2] = obj->value[1];
magic.c:      xREMOVE_BIT( obj->extra_flags, ITEM_INVIS );
magic.c:            obj_next = obj->next_content;
magic.c:            if( obj->item_type != ITEM_DRINK_CON )
magic.c:            if( ( !liq || liq->vnum != obj->value[2] ) && obj->value[1] != 0 )
magic.c:                          * ( getPrecip( cell ) >= 0 ? 2 : 1 ), obj->value[0] - obj->value[1] );
magic.c:               obj->value[2] = liq->vnum;
magic.c:               obj->value[1] += water;
magic.c:               if( !is_name( "water", obj->name ) )
magic.c:                  snprintf( buf, MAX_STRING_LENGTH, "%s water", obj->name );
magic.c:                  STRFREE( obj->name );
magic.c:                  obj->name = STRALLOC( buf );
magic.c:            switch ( obj->item_type )
magic.c:                  obj->value[3] = 1;
magic.c:             && ( obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_COOK ) )
magic.c:            switch ( obj->item_type )
magic.c:                  obj->value[3] = 0;
magic.c:               if( ch->level - obj->level < 10 || obj->cost > ch->level * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 20 || obj->cost > ch->level * get_curr_int( ch ) / 5 )
magic.c:               if( ch->level - obj->level < 5 || obj->cost > ch->level * 10 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:               if( ch->level - obj->level < 0 || obj->cost > ch->level * 50 * get_curr_int( ch ) * get_curr_wis( ch ) )
magic.c:            if( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD || obj->item_type == ITEM_COOK )
magic.c:               if( obj->item_type == ITEM_COOK && obj->value[2] == 0 )
magic.c:               else if( obj->value[3] != 0 )
magic.c:         xSET_BIT( obj->extra_flags, ITEM_INVIS );
magic.c:   obj->timer = skill->dice ? dice_parse( ch, level, skill->dice ) : 0;
magic.c:   if( !CAN_WEAR( obj, ITEM_TAKE ) || ( obj->item_type == ITEM_CORPSE_NPC ) || ( obj->item_type == ITEM_CORPSE_PC ) || ( obj->item_type == ITEM_KEY ) )
magic.c:   val = obj->cost / 2;
magic.c:   if( cur_obj == obj->serial )
makeobjs.c:   if( obj->pIndexData->vnum == OBJ_VNUM_SCRAPS )
makeobjs.c:      snprintf( buf, MAX_STRING_LENGTH, scraps->short_descr, obj->short_descr );
makeobjs.c:      snprintf( buf, MAX_STRING_LENGTH, scraps->description, obj->short_descr );
makeobjs.c:   if( obj->carried_by )
makeobjs.c:      act( AT_OBJECT, "$p falls to the ground in scraps!", obj->carried_by, obj, NULL, TO_CHAR );
makeobjs.c:      if( obj == get_eq_char( obj->carried_by, WEAR_WIELD )
makeobjs.c:          && ( tmpobj = get_eq_char( obj->carried_by, WEAR_DUAL_WIELD ) ) != NULL )
makeobjs.c:         tmpobj->wear_loc = WEAR_WIELD;
makeobjs.c:      obj_to_room( scraps, obj->carried_by->in_room );
makeobjs.c:   else if( obj->in_room )
makeobjs.c:      if( ( ch = obj->in_room->first_person ) != NULL )
makeobjs.c:      obj_to_room( scraps, obj->in_room );
makeobjs.c:   if( ( obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_KEYRING
makeobjs.c:         || obj->item_type == ITEM_QUIVER || obj->item_type == ITEM_CORPSE_PC ) && obj->first_content )
makeobjs.c:      if( obj->carried_by )
makeobjs.c:         empty_obj( obj, NULL, obj->carried_by->in_room );
makeobjs.c:      else if( obj->in_room )
makeobjs.c:         empty_obj( obj, NULL, obj->in_room );
makeobjs.c:      else if( obj->in_obj )
makeobjs.c:         empty_obj( obj, obj->in_obj, NULL );
makeobjs.c:      obj_next = obj->next_content;
makeobjs.c:   for(obj = ch->in_room->first_content; obj; obj = obj->next_content )
makeobjs.c:      if( obj->pIndexData->item_type == ITEM_PUDDLE )
makeobjs.c:         if( obj->value[2] == cont->value[2] )
makeobjs.c:            obj->value[1] += cont->value[1];
makeobjs.c:            obj->value[3] += cont->value[3];
makeobjs.c:            obj->timer = number_range( 2, 4 );
makeobjs.c:      obj->timer = number_range( 2, 4 );
makeobjs.c:      obj->value[1] += cont->value[1];
makeobjs.c:      obj->value[2] = cont->value[2];
makeobjs.c:      obj->value[3] = cont->value[3];
makeobjs.c:   liq = get_liq_vnum( obj->value[2] );
makeobjs.c:   if( obj->value[1] > 15 )
makeobjs.c:   else if( obj->value[1] > 10 )
makeobjs.c:   else if( obj->value[1] > 5 )
makeobjs.c:   obj->description = STRALLOC( buf2 );
makeobjs.c:      if( obj->pIndexData->vnum == OBJ_VNUM_BLOOD )
makeobjs.c:         obj->description = STRALLOC( "A large pool of spilled blood lies here." );
makeobjs.c:         obj->value[1] += number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:         obj->timer = number_range( 2, 4 );
makeobjs.c:      obj_next = obj->next_content;
makeobjs.c:   obj->timer = number_range( 2, 4 );
makeobjs.c:   obj->value[1] = number_range( 3, UMIN( 5, ch->level ) );
makeobjs.c:   obj->timer = number_range( 1, 2 );
makeobjs.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, amount );
makeobjs.c:      STRFREE( obj->short_descr );
makeobjs.c:      obj->short_descr = STRALLOC( buf );
makeobjs.c:      obj->value[0] = amount;
misc.c:      if( obj->item_type != ITEM_FOOD && obj->item_type != ITEM_PILL && obj->item_type != ITEM_COOK )
misc.c:   if( obj->in_obj )
misc.c:         act( AT_PLAIN, "You take $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:      act( AT_PLAIN, "$n takes $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:         if( !obj->action_desc || obj->action_desc[0] == '\0' )
misc.c:      switch ( obj->item_type )
misc.c:            if( obj->timer > 0 && obj->value[1] > 0 )
misc.c:               foodcond = ( obj->timer * 10 ) / obj->value[1];
misc.c:               gain_condition( ch, COND_FULL, ( obj->value[0] * foodcond ) / 10 );
misc.c:            if( obj->value[3] != 0
misc.c:                || ( obj->item_type == ITEM_COOK && obj->value[2] == 0 ) )
misc.c:               if( obj->value[3] != 0 )
misc.c:               af.duration = 2 * obj->value[0] * ( obj->value[3] > 0 ? obj->value[3] : 1 );
misc.c:            sysdata.upill_val += obj->cost / 100;
misc.c:            if( !IS_NPC( ch ) && obj->value[4] )
misc.c:               gain_condition( ch, COND_FULL, obj->value[4] );
misc.c:            retcode = obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
misc.c:               retcode = obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
misc.c:               retcode = obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
misc.c:   if( obj->serial == cur_obj )
misc.c:   if( obj->item_type != ITEM_POTION )
misc.c:      if( obj->item_type == ITEM_DRINK_CON )
misc.c:         do_drink( ch, obj->name );
misc.c:   if( obj->value[1] == -1 && obj->value[2] == -1 && obj->value[3] == -1 )
misc.c:   if( obj->in_obj )
misc.c:         act( AT_PLAIN, "You take $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:         act( AT_PLAIN, "$n takes $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:         if( !CAN_PKILL( ch ) || !obj->in_obj )
misc.c:         else if( obj->in_obj )
misc.c:            act( AT_ACTION, "$n quaffs $p from $P.", ch, obj, obj->in_obj, TO_ROOM );
misc.c:               act( AT_ACTION, "You quaff $p from $P.", ch, obj, obj->in_obj, TO_CHAR );
misc.c:      retcode = obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
misc.c:         retcode = obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
misc.c:         retcode = obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
misc.c:   if( obj->pIndexData->vnum == OBJ_VNUM_FLASK_BREWING )
misc.c:      sysdata.upotion_val += obj->cost / 100;
misc.c:   if( cur_obj == obj->serial )
misc.c:   if( IS_SET( obj->value[0], TRIG_UP ) )
misc.c:   switch ( obj->item_type )
misc.c:   if( ( pull ) && HAS_PROG( obj->pIndexData, PULL_PROG ) )
misc.c:      if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         REMOVE_BIT( obj->value[0], TRIG_UP );
misc.c:   if( ( !pull ) && HAS_PROG( obj->pIndexData, PUSH_PROG ) )
misc.c:      if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         SET_BIT( obj->value[0], TRIG_UP );
misc.c:   if( !IS_SET( obj->value[0], TRIG_AUTORETURN ) )
misc.c:         REMOVE_BIT( obj->value[0], TRIG_UP );
misc.c:         SET_BIT( obj->value[0], TRIG_UP );
misc.c:   if( IS_SET( obj->value[0], TRIG_TELEPORT )
misc.c:       || IS_SET( obj->value[0], TRIG_TELEPORTALL ) || IS_SET( obj->value[0], TRIG_TELEPORTPLUS ) )
misc.c:      if( ( room = get_room_index( obj->value[1] ) ) == NULL )
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_SHOWROOMDESC ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_TELEPORTALL ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_TELEPORTPLUS ) )
misc.c:      teleport( ch, obj->value[1], flags );
misc.c:   if( IS_SET( obj->value[0], TRIG_RAND4 ) || IS_SET( obj->value[0], TRIG_RAND6 ) )
misc.c:      if( ( room = get_room_index( obj->value[1] ) ) == NULL )
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_RAND4 ) )
misc.c:   if( IS_SET( obj->value[0], TRIG_DEATH ) )
misc.c:   if( IS_SET( obj->value[0], TRIG_OLOAD ) )
misc.c:      if( !( pObjIndex = get_obj_index( obj->value[1] ) ) )
misc.c:         bug( "%s: obj points to invalid object vnum %d", __func__, obj->value[1] );
misc.c:      if( obj->value[2] > 0 && !( room = get_room_index( obj->value[2] ) ) )
misc.c:         bug( "%s: obj points to invalid room vnum %d", __func__, obj->value[2] );
misc.c:      if( !( tobj = create_object( pObjIndex, URANGE( 0, obj->value[3], MAX_LEVEL ) ) ) )
misc.c:         bug( "%s: obj couldnt create_obj vnum %d at level %d", __func__, obj->value[1], obj->value[3] );
misc.c:   if( IS_SET( obj->value[0], TRIG_MLOAD ) )
misc.c:      if( !( pMobIndex = get_mob_index( obj->value[1] ) ) )
misc.c:         bug( "%s: obj points to invalid mob vnum %d", __func__, obj->value[1] );
misc.c:      if( obj->value[2] > 0 && !( room = get_room_index( obj->value[2] ) ) )
misc.c:         bug( "%s: obj points to invalid room vnum %d", __func__, obj->value[2] );
misc.c:         bug( "%s: obj couldnt create_mobile vnum %d", __func__, obj->value[1] );
misc.c:   if( IS_SET( obj->value[0], TRIG_CAST ) )
misc.c:      if( obj->value[1] <= 0 || !IS_VALID_SN( obj->value[1] ) )
misc.c:         bug( "%s: obj points to invalid sn [%d]", __func__, obj->value[1] );
misc.c:      obj_cast_spell( obj->value[1], URANGE( 1, ( obj->value[2] > 0 ) ? obj->value[2] : ch->level, MAX_LEVEL ), ch, ch,
misc.c:   if( IS_SET( obj->value[0], TRIG_CONTAINER ) )
misc.c:      room = get_room_index( obj->value[1] );
misc.c:         room = obj->in_room;
misc.c:         bug( "%s: obj points to invalid room %d", __func__, obj->value[1] );
misc.c:         if( container->pIndexData->vnum == obj->value[2] )
misc.c:         bug( "%s: obj points to a container [%d] thats not where it should be?", __func__, obj->value[2] );
misc.c:         bug( "%s: obj points to object [%d], but it isn't a container.", __func__, obj->value[2] );
misc.c:      if( IS_SET( obj->value[3], CONT_CLOSEABLE ) )
misc.c:      if( IS_SET( obj->value[3], CONT_PICKPROOF ) )
misc.c:      if( IS_SET( obj->value[3], CONT_CLOSED ) )
misc.c:      if( IS_SET( obj->value[3], CONT_LOCKED ) )
misc.c:      if( IS_SET( obj->value[3], CONT_EATKEY ) )
misc.c:   if( IS_SET( obj->value[0], TRIG_DOOR ) )
misc.c:      room = get_room_index( obj->value[1] );
misc.c:         room = obj->in_room;
misc.c:         bug( "PullOrPush: obj points to invalid room %d", obj->value[1] );
misc.c:      if( IS_SET( obj->value[0], TRIG_D_NORTH ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_SOUTH ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_EAST ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_WEST ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_UP ) )
misc.c:      else if( IS_SET( obj->value[0], TRIG_D_DOWN ) )
misc.c:         if( !IS_SET( obj->value[0], TRIG_PASSAGE ) )
misc.c:            bug( "PullOrPush: obj points to non-exit %d", obj->value[1] );
misc.c:         to_room = get_room_index( obj->value[2] );
misc.c:            bug( "PullOrPush: dest points to invalid room %d", obj->value[2] );
misc.c:      if( IS_SET( obj->value[0], TRIG_UNLOCK ) && IS_SET( pexit->exit_info, EX_LOCKED ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_LOCK ) && !IS_SET( pexit->exit_info, EX_LOCKED ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_OPEN ) && IS_SET( pexit->exit_info, EX_CLOSED ) )
misc.c:      if( IS_SET( obj->value[0], TRIG_CLOSE ) && !IS_SET( pexit->exit_info, EX_CLOSED ) )
misc.c:   if( obj->item_type != ITEM_LIGHT || ( obj->value[1] < 1 ) )
misc.c:   if( IS_SET( obj->value[3], PIPE_LIT ) )
misc.c:      REMOVE_BIT( obj->value[3], PIPE_LIT );
misc.c:   switch( obj->item_type )
misc.c:         if( !IS_SET( obj->value[3], PIPE_LIT ) )
misc.c:            if( obj->value[1] < 1 )
misc.c:            SET_BIT( obj->value[3], PIPE_LIT );
misc.c:         if( obj->value[1] > 0 )
misc.c:            if( !IS_SET( obj->value[3], PIPE_LIT ) )
misc.c:               SET_BIT( obj->value[3], PIPE_LIT );
misc.c:   const char *srcptr = obj->action_desc;
misc.c:   switch ( obj->item_type )
misc.c:         LIQ_TABLE *liq = get_liq_vnum( obj->value[2] );
mpxset.c:      obj->value[0] = value;
mpxset.c:      obj->value[1] = value;
mpxset.c:      obj->value[2] = value;
mpxset.c:      obj->value[3] = value;
mpxset.c:      obj->value[4] = value;
mpxset.c:      obj->value[5] = value;
mpxset.c:      obj->item_type = ( short )value;
mpxset.c:               xTOGGLE_BIT( obj->extra_flags, value );
mpxset.c:            TOGGLE_BIT( obj->wear_flags, 1 << value );
mpxset.c:      obj->level = value;
mpxset.c:      obj->weight = value;
mpxset.c:      obj->cost = value;
mpxset.c:      obj->timer = value;
mpxset.c:      STRFREE( obj->name );
mpxset.c:      obj->name = STRALLOC( arg3 );
mpxset.c:      STRFREE( obj->short_descr );
mpxset.c:      obj->short_descr = STRALLOC( arg3 );
mpxset.c:         supermob->short_descr = QUICKLINK( obj->short_descr );
mpxset.c:      if( str_infix( "mprename", obj->name ) )
mpxset.c:         snprintf( buf, MAX_STRING_LENGTH, "%s %s", obj->name, "mprename" );
mpxset.c:         STRFREE( obj->name );
mpxset.c:         obj->name = STRALLOC( buf );
mpxset.c:      STRFREE( obj->description );
mpxset.c:      obj->description = STRALLOC( buf );
mpxset.c:      STRFREE( obj->action_desc );
mpxset.c:      obj->action_desc = STRALLOC( arg3 );
mpxset.c:      LINK( paf, obj->first_affect, obj->last_affect, next, prev );
mpxset.c:      for( paf = obj->first_affect; paf; paf = paf->next )
mpxset.c:            UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
mpxset.c:   switch ( obj->item_type )
mpxset.c:      obj->value[tmp] = value;
mud_comm.c:   if( xIS_EMPTY( obj->pIndexData->progtypes ) )
mud_comm.c:      ch_printf( ch, "No programs on object:  %s - #%d\r\n", obj->short_descr, obj->pIndexData->vnum );
mud_comm.c:   ch_printf( ch, "Name: %s.  Vnum: %d.\r\n", obj->name, obj->pIndexData->vnum );
mud_comm.c:   ch_printf( ch, "Short description: %s.\r\n", obj->short_descr );
mud_comm.c:   for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_comm.c:         obj_next = obj->next_content;
mud_comm.c:         if( arg[3] == '\0' || is_name( &arg[4], obj->name ) )
mud_comm.c:            if( obj->wear_loc != WEAR_NONE )
mud_comm.c:   obj->timer = timer;
mud_comm.c:   for( obj = first_object; obj; obj = obj->next )
mud_comm.c:      if( obj->in_room && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC && !str_cmp( buf2, obj->short_descr ) )
mud_comm.c:         obj->timer = -1;
mud_comm.c:      STRFREE( obj->owner );
mud_comm.c:      obj->owner = STRALLOC( "" );
mud_comm.c:      xREMOVE_BIT( obj->extra_flags, ITEM_PERSONAL );
mud_comm.c:   xSET_BIT( obj->extra_flags, ITEM_PERSONAL );
mud_comm.c:   STRFREE( obj->owner );
mud_comm.c:   obj->owner = STRALLOC( victim->name );
mud_prog.c:         supermob->short_descr = QUICKLINK( supermob_obj->short_descr );
mud_prog.c:         snprintf( buf, 128, "Object #%d", supermob_obj->pIndexData->vnum );
mud_prog.c:   if( obj->wear_loc == -1 && obj->pIndexData->vnum == vnum )
mud_prog.c:   if( obj->first_content )   /* node has a child? */
mud_prog.c:      if( carryingvnum_visit( ch, obj->first_content, vnum ) )
mud_prog.c:      if( obj->next_content ) /* node has a sibling? */
mud_prog.c:         if( carryingvnum_visit( ch, obj->next_content, vnum ) )
mud_prog.c:   else if( obj->next_content )  /* node has a sibling? */
mud_prog.c:      if( carryingvnum_visit( ch, obj->next_content, vnum ) )
mud_prog.c:         for( tobj = chkchar->first_carrying; tobj; tobj = tobj->next_content )
mud_prog.c:            if( chkchar == tobj->carried_by && tobj->wear_loc > -1 && !str_cmp( rval, item_w_flags[tobj->wear_loc] ) )
mud_prog.c:         for( tobj = chkchar->first_carrying; tobj; tobj = tobj->next_content )
mud_prog.c:            if( chkchar == tobj->carried_by && tobj->wear_loc > -1 && tobj->pIndexData->vnum == atoi( rval ) )
mud_prog.c:         return mprog_veval( chkobj->item_type, opr, atoi( rval ), mob );
mud_prog.c:         if( chkobj->item_type != ITEM_SWITCH && chkobj->item_type != ITEM_LEVER && chkobj->item_type != ITEM_PULLCHAIN
mud_prog.c:             && chkobj->item_type != ITEM_BUTTON )
mud_prog.c:         if( IS_SET( obj->value[0], TRIG_UP ) )
mud_prog.c:         return mprog_veval( chkobj->value[0], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[1], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[2], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[3], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[4], opr, atoi( rval ), mob );
mud_prog.c:         return mprog_veval( chkobj->value[5], opr, atoi( rval ), mob );
mud_prog.c:      return mprog_veval( chkobj->pIndexData->vnum, opr, atoi( rval ), mob );
mud_prog.c:      return mprog_seval( chkobj->name, opr, rval, mob );
mud_prog.c:            can_see_obj( mob, obj ) ? one_argument( obj->name, t ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, obj ) ? strcpy( t, obj->short_descr ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, v_obj ) ? one_argument( v_obj->name, t ) : strcpy( t, "something" );
mud_prog.c:            can_see_obj( mob, v_obj ) ? strcpy( t, v_obj->short_descr ) : strcpy( t, "something" );
mud_prog.c:            strcpy( t, aoran( obj->name ) );
mud_prog.c:          switch ( *( obj->name ) )
mud_prog.c:            strcpy( t, aoran( v_obj->name ) );
mud_prog.c:      snprintf( buf, MAX_STRING_LENGTH, obj->short_descr, amount );
mud_prog.c:      STRFREE( obj->short_descr );
mud_prog.c:      obj->short_descr = STRALLOC( buf );
mud_prog.c:      obj->value[0] = amount;
mud_prog.c:         if( mprg->type == GIVE_PROG && ( !str_cmp( obj->name, mprg->arglist ) || !str_cmp( "all", buf ) ) )
mud_prog.c:         if( mprg->type == SELL_PROG && ( ( s_vnum == obj->pIndexData->vnum ) || ( s_vnum == 0 ) ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, SCRIPT_PROG ) )
mud_prog.c:      for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:            if( mprg->arglist[0] == '\0' || obj->mpscriptpos != 0 || atoi( mprg->arglist ) == time_info.hour )
mud_prog.c:               obj->mpscriptpos = supermob->mpscriptpos;
mud_prog.c:   for( in_obj = obj; in_obj->in_obj; in_obj = in_obj->in_obj )
mud_prog.c:   if( in_obj->carried_by )
mud_prog.c:      room = in_obj->carried_by->in_room;
mud_prog.c:      room = obj->in_room;
mud_prog.c:   supermob->short_descr = QUICKLINK( obj->short_descr );
mud_prog.c:   supermob->mpscriptpos = obj->mpscriptpos;
mud_prog.c:   snprintf( buf, 200, "Object #%d", obj->pIndexData->vnum );
mud_prog.c:   for( mprg = obj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:      if( HAS_PROG( vobj->pIndexData, GREET_PROG ) )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:      if( HAS_PROG( vobj->pIndexData, SPEECH_PROG ) )
mud_prog.c:   for( vobj = ch->in_room->first_content; vobj; vobj = vobj->next_content )
mud_prog.c:      if( HAS_PROG( vobj->pIndexData, CMD_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, RAND_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, WEAR_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, USE_PROG ) )
mud_prog.c:      if( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND || obj->item_type == ITEM_SCROLL )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, REMOVE_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, SAC_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, GET_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, DAMAGE_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, REPAIR_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, DROP_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, EXA_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, ZAP_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, PULL_PROG ) )
mud_prog.c:   if( HAS_PROG( obj->pIndexData, PUSH_PROG ) )
mud_prog.c:   if( HAS_PROG( mobj->pIndexData, ACT_PROG ) )
mud_prog.c:      if( mobj->mpactnum > 0 )
mud_prog.c:         tmp_mal = mobj->mpact;
mud_prog.c:         mobj->mpact = tmp_act;
mud_prog.c:      mobj->mpact = tmp_act;
mud_prog.c:      mobj->mpact->buf = str_dup( buf );
mud_prog.c:      mobj->mpact->ch = ch;
mud_prog.c:      mobj->mpact->obj = obj;
mud_prog.c:      mobj->mpact->victim = victim;
mud_prog.c:      mobj->mpact->target = target;
mud_prog.c:      mobj->mpactnum++;
mud_prog.c:   for( mprg = iobj->pIndexData->mudprogs; mprg; mprg = mprg->next )
mud_prog.c:      while( ( mpact = obj->mpact ) != NULL )
mud_prog.c:         obj->mpact = mpact->next;
mud_prog.c:      obj->mpact = NULL;
mud_prog.c:      obj->mpactnum = 0;
player.c:   for( obj = first_object; obj; obj = obj->next )
player.c:      if( obj->in_room && !str_cmp( buf, obj->short_descr ) && ( obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC ) )
player.c:         pager_printf( ch, "\r\n  - at %s will endure for %d ticks", obj->in_room->name, obj->timer );
player.c:      for( obj = victim->first_carrying; obj; obj = obj->next_content )
player.c:         if( obj->wear_loc == iWear )
polymorph.c:         act( AT_OBJECT, "$p disappears in a whisp of smoke!", obj->carried_by, obj, NULL, TO_CHAR );
polymorph.c:         if( obj == get_eq_char( obj->carried_by, WEAR_WIELD )
polymorph.c:             && ( tmpobj = get_eq_char( obj->carried_by, WEAR_DUAL_WIELD ) ) != NULL )
polymorph.c:            tmpobj->wear_loc = WEAR_WIELD;
polymorph.c:         act( AT_OBJECT, "$p disappears in a whisp of smoke!", obj->carried_by, obj, NULL, TO_CHAR );
polymorph.c:         if( obj == get_eq_char( obj->carried_by, WEAR_WIELD )
polymorph.c:             && ( tmpobj = get_eq_char( obj->carried_by, WEAR_DUAL_WIELD ) ) != NULL )
polymorph.c:            tmpobj->wear_loc = WEAR_WIELD;
polymorph.c:         act( AT_OBJECT, "$p disappears in a whisp of smoke!", obj->carried_by, obj, NULL, TO_CHAR );
polymorph.c:         if( obj == get_eq_char( obj->carried_by, WEAR_WIELD )
polymorph.c:             && ( tmpobj = get_eq_char( obj->carried_by, WEAR_DUAL_WIELD ) ) != NULL )
polymorph.c:            tmpobj->wear_loc = WEAR_WIELD;
renumber.c:         obj_index_hash[iHash] = obj->next;
renumber.c:         obj_prev->next = obj->next;
renumber.c:         obj->next = NULL;
renumber.c:      obj->vnum = r_data->new_vnum;
renumber.c:      obj->next = obj_list;
renumber.c:      obj_next = obj->next;
renumber.c:      iHash = obj->vnum % MAX_KEY_HASH;
renumber.c:      obj->next = obj_index_hash[iHash];
renumber.c:      if( obj->item_type == ITEM_CONTAINER )
renumber.c:         new_vnum = find_translation( obj->value[2], r_area->r_obj );
renumber.c:               pager_printf( ch, "...    container %d; fixing objval2 (key vnum) %d -> %d\r\n", i, obj->value[2], new_vnum );
renumber.c:            obj->value[2] = new_vnum;
renumber.c:      else if( obj->item_type == ITEM_SWITCH || obj->item_type == ITEM_LEVER ||
renumber.c:               obj->item_type == ITEM_PULLCHAIN || obj->item_type == ITEM_BUTTON )
renumber.c:         if( IS_SET( obj->value[0], TRIG_TELEPORT )
renumber.c:             || IS_SET( obj->value[0], TRIG_TELEPORTALL )
renumber.c:             || IS_SET( obj->value[0], TRIG_TELEPORTPLUS )
renumber.c:             || IS_SET( obj->value[0], TRIG_RAND4 )
renumber.c:             || IS_SET( obj->value[0], TRIG_RAND6 ) || IS_SET( obj->value[0], TRIG_DOOR ) )
renumber.c:            new_vnum = find_translation( obj->value[1], r_area->r_room );
renumber.c:                  pager_printf( ch, "...    lever %d: fixing source room (%d -> %d)\r\n", i, obj->value[1], new_vnum );
renumber.c:               obj->value[1] = new_vnum;
renumber.c:            if( IS_SET( obj->value[0], TRIG_DOOR ) && IS_SET( obj->value[0], TRIG_PASSAGE ) )
renumber.c:               new_vnum = find_translation( obj->value[2], r_area->r_room );
renumber.c:                                   i, obj->value[2], new_vnum );
renumber.c:                  obj->value[2] = new_vnum;
renumber.c:      mprog = obj->mudprogs;
reset.c:   for( obj = first_object; obj; obj = obj->next )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:   for( obj = pRoomIndex->first_content; obj; obj = obj->next_content )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:                     strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:                     strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:                           strncpy( roomname, obj->name, MAX_STRING_LENGTH );
reset.c:                                  obj ? obj->vnum : gReset->arg3, gReset->arg2 );
reset.c:            strncpy( objname, obj->name, MAX_STRING_LENGTH );
reset.c:                     strncpy( roomname, obj->name, MAX_STRING_LENGTH );
reset.c:                            *num, objname, tReset->arg1, roomname, obj ? obj->vnum : tReset->arg3, tReset->arg2 );
reset.c:                            tReset->arg3, flag_string( tReset->extra, trap_flags ), objname, obj ? obj->vnum : 0 );
reset.c:   if( ( cm == 'O' || cm == 'P' ) && obj->pIndexData->vnum == OBJ_VNUM_TRAP )
reset.c:         add_reset( room, 'T', obj->value[3], obj->value[1], obj->value[0], v3 );
reset.c:   add_reset( room, cm, ( cm == 'P' ? iNest : 0 ), obj->pIndexData->vnum, v2, v3 );
reset.c:   for( inobj = obj->first_content; inobj; inobj = inobj->next_content )
reset.c:      if( inobj->pIndexData->vnum == OBJ_VNUM_TRAP )
reset.c:   for( inobj = obj->first_content; inobj; inobj = inobj->next_content )
reset.c:      add_obj_reset( room, 'P', inobj, inobj->count, obj->pIndexData->vnum );
reset.c:      for( obj = rch->first_carrying; obj; obj = obj->next_content )
reset.c:         if( obj->wear_loc == WEAR_NONE )
reset.c:            add_obj_reset( pRoom, 'E', obj, 1, obj->wear_loc );
reset.c:   for( obj = pRoom->first_content; obj; obj = obj->next_content )
reset.c:      add_obj_reset( pRoom, 'O', obj, obj->count, pRoom->vnum );
reset.c:   for( obj = list; obj; obj = obj->next_content )
reset.c:      if( obj->pIndexData == pObjIndex )
reset.c:         nMatch += obj->count;
reset.c:                           xSET_BIT( obj->extra_flags, ITEM_INVENTORY );
reset.c:                        obj->level = URANGE( 0, obj->level, LEVEL_AVATAR );
reset.c:                           if( obj->carried_by != mob )
reset.c:                              bug( "'E' reset: can't give object %d to mob %d.", obj->pIndexData->vnum,
reset.c:                                    xSET_BIT( lastobj->extra_flags, ITEM_HIDDEN );
reset.c:                                    if( count_obj_list( pObjIndex, to_obj->first_content ) > 0 )
reset.c:                                                                      to_obj->level ) ) );
reset.c:                                    obj->count = gReset->arg2;
reset.c:                                    obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:                                    obj->count = gReset->arg2;
reset.c:                                       gReset->arg3 = to_obj->pIndexData->vnum;
reset.c:               obj->count = pReset->arg2;
reset.c:               obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:               obj->cost = 0;
reset.c:               obj->extra_flags = pObjIndex->extra_flags;
reset.c:                  obj->value[x] = pObjIndex->value[x];
reset.c:                        xSET_BIT( lastobj->extra_flags, ITEM_HIDDEN );
reset.c:                                  ( to_obj->carried_by && !IS_NPC( to_obj->carried_by ) ) || is_trapped( to_obj ) )
reset.c:                           pobj = make_trap( tReset->arg2, tReset->arg1, number_fuzzy( to_obj->level ), tReset->extra );
reset.c:                        if( count_obj_list( pObjIndex, to_obj->first_content ) > 0 )
reset.c:                                                        ( generate_itemlevel( room->area, pObjIndex ), to_obj->level ) ) );
reset.c:                        obj->count = tReset->arg2;
reset.c:                        obj->level = UMIN( obj->level, LEVEL_AVATAR );
reset.c:                        obj->count = tReset->arg2;
reset.c:                           tReset->arg3 = to_obj->pIndexData->vnum;
reset.c:                        else if( lastobj->command != 'P' || lastobj->arg3 > 0 )
reset.c:                           tReset->extra = lastobj->extra + 1;
reset.c:      if( is_name( arg, pobj->name ) && ++cnt == num )
save.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
save.c:      if( obj->wear_loc > -1 && obj->wear_loc < MAX_WEAR )
save.c:         if( get_trust( ch ) >= obj->level )
save.c:                  if( !mob_save_equipment[obj->wear_loc][x] )
save.c:                     mob_save_equipment[obj->wear_loc][x] = obj;
save.c:                  if( !save_equipment[obj->wear_loc][x] )
save.c:                     save_equipment[obj->wear_loc][x] = obj;
save.c:                    ch->name, MAX_LAYERS, obj->wear_loc, obj->name );
save.c:            bug( "%s had on %s:  ch->level = %d  obj->level = %d", ch->name, obj->name, ch->level, obj->level );
save.c:   if( obj->prev_content && os_type != OS_CORPSE )
save.c:      fwrite_obj( ch, obj->prev_content, fp, iNest, os_type, hotboot );
save.c:      if( (ch && ch->level < obj->level)
save.c:         || ( obj->item_type == ITEM_KEY && !IS_OBJ_STAT( obj, ITEM_CLANOBJECT ) )
save.c:         || ( (os_type == OS_VAULT) && (obj->item_type == ITEM_CORPSE_PC) )
save.c:   if( hotboot && obj->item_type == ITEM_CORPSE_PC )
save.c:   if( obj->count > 1 )
save.c:      fprintf( fp, "Count        %d\n", obj->count );
save.c:   if( obj->name && ( !obj->pIndexData->name || str_cmp( obj->name, obj->pIndexData->name ) ) )
save.c:      fprintf( fp, "Name         %s~\n", obj->name );
save.c:   if( obj->short_descr && ( !obj->pIndexData->short_descr || str_cmp( obj->short_descr, obj->pIndexData->short_descr ) ) )
save.c:      fprintf( fp, "ShortDescr   %s~\n", obj->short_descr );
save.c:   if( obj->description && ( !obj->pIndexData->description || str_cmp( obj->description, obj->pIndexData->description ) ) )
save.c:      fprintf( fp, "Description  %s~\n", obj->description );
save.c:   if( obj->action_desc && ( !obj->pIndexData->action_desc || str_cmp( obj->action_desc, obj->pIndexData->action_desc ) ) )
save.c:      fprintf( fp, "ActionDesc   %s~\n", obj->action_desc );
save.c:   if( obj->owner && obj->owner[0] != '\0' )
save.c:      fprintf( fp, "Owner        %s~\n", obj->owner );
save.c:   fprintf( fp, "Vnum         %d\n", obj->pIndexData->vnum );
save.c:   if( ( os_type == OS_CORPSE || os_type == OS_VAULT || hotboot ) && obj->in_room )
save.c:      fprintf( fp, "Room      %d\n", obj->in_room->vnum );
save.c:      fprintf( fp, "Rvnum	   %d\n", obj->room_vnum );
save.c:   if( !xSAME_BITS( obj->extra_flags, obj->pIndexData->extra_flags ) )
save.c:      fprintf( fp, "ExtraFlags   %s\n", print_bitvector( &obj->extra_flags ) );
save.c:   if( obj->wear_flags != obj->pIndexData->wear_flags )
save.c:      fprintf( fp, "WearFlags    %d\n", obj->wear_flags );
save.c:   if( obj->item_type != obj->pIndexData->item_type )
save.c:      fprintf( fp, "ItemType     %d\n", obj->item_type );
save.c:   if( obj->weight != obj->pIndexData->weight )
save.c:      fprintf( fp, "Weight       %d\n", obj->weight );
save.c:   if( obj->level )
save.c:      fprintf( fp, "Level        %d\n", obj->level );
save.c:   if( obj->timer )
save.c:      fprintf( fp, "Timer        %d\n", obj->timer );
save.c:   if( obj->cost != obj->pIndexData->cost )
save.c:      fprintf( fp, "Cost         %d\n", obj->cost );
save.c:   if( obj->value[0] || obj->value[1] || obj->value[2] || obj->value[3] || obj->value[4] || obj->value[5] )
save.c:               obj->value[0], obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5] );
save.c:   if( obj->item_type == ITEM_ARMOR )
save.c:      fprintf( fp, "ArmorType    %d\n", obj->armor_type );
save.c:   switch ( obj->item_type )
save.c:         if( IS_VALID_SN( obj->value[1] ) )
save.c:            fprintf( fp, "Spell 1      '%s'\n", skill_table[obj->value[1]]->name );
save.c:         if( IS_VALID_SN( obj->value[2] ) )
save.c:            fprintf( fp, "Spell 2      '%s'\n", skill_table[obj->value[2]]->name );
save.c:         if( IS_VALID_SN( obj->value[3] ) )
save.c:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c:         if( IS_VALID_SN( obj->value[3] ) )
save.c:            fprintf( fp, "Spell 3      '%s'\n", skill_table[obj->value[3]]->name );
save.c:         if( IS_VALID_SN( obj->value[4] ) )
save.c:            fprintf( fp, "Spell 4      '%s'\n", skill_table[obj->value[4]]->name );
save.c:         if( IS_VALID_SN( obj->value[5] ) )
save.c:            fprintf( fp, "Spell 5      '%s'\n", skill_table[obj->value[5]]->name );
save.c:   for( paf = obj->first_affect; paf; paf = paf->next )
save.c:   for( ed = obj->first_extradesc; ed; ed = ed->next )
save.c:   if( obj->first_content )
save.c:      fwrite_obj( ch, obj->last_content, fp, iNest + 1, OS_CARRY, hotboot );
save.c:      if( home->vnum[0] == obj->pIndexData->vnum )
save.c:         if( !str_cmp( home->name, obj->owner ) )
save.c:   obj->count = 1;
save.c:   obj->wear_loc = -1;
save.c:   obj->weight = 1;
save.c:   obj->owner = STRALLOC( "" );
save.c:            KEY( "ActionDesc", obj->action_desc, fread_string( fp ) );
save.c:            KEY( "ArmorType", obj->armor_type, fread_number ( fp ) );
save.c:               LINK( paf, obj->first_affect, obj->last_affect, next, prev );
save.c:            KEY( "Cost", obj->cost, fread_number( fp ) );
save.c:            KEY( "Count", obj->count, fread_number( fp ) );
save.c:            KEY( "Description", obj->description, fread_string( fp ) );
save.c:            KEY( "ExtraFlags", obj->extra_flags, fread_bitvector( fp ) );
save.c:               LINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c:               if( obj->item_type == ITEM_HOUSEKEY )
save.c:                     if( obj->name )
save.c:                        STRFREE( obj->name );
save.c:                     if( obj->description )
save.c:                        STRFREE( obj->description );
save.c:                     if( obj->short_descr )
save.c:                        STRFREE( obj->short_descr );
save.c:                  if( obj->name )
save.c:                     bug( "%s: %s incomplete object.", __func__, obj->name );
save.c:                  short wear_loc = obj->wear_loc;
save.c:                  if( !obj->name )
save.c:                     obj->name = QUICKLINK( obj->pIndexData->name );
save.c:                  if( !obj->description )
save.c:                     obj->description = QUICKLINK( obj->pIndexData->description );
save.c:                  if( !obj->short_descr )
save.c:                     obj->short_descr = QUICKLINK( obj->pIndexData->short_descr );
save.c:                  if( !obj->action_desc )
save.c:                     obj->action_desc = QUICKLINK( obj->pIndexData->action_desc );
save.c:                  if( IS_OBJ_STAT( obj, ITEM_PERSONAL ) && !obj->owner && ch )
save.c:                     obj->owner = QUICKLINK( ch->name );
save.c:                  if( !obj->owner )
save.c:                     obj->owner = STRALLOC( "" );
save.c:                  obj->pIndexData->count += obj->count;
save.c:                  if( !obj->serial )
save.c:                     obj->serial = obj->pIndexData->serial = cur_obj_serial;
save.c:                  numobjsloaded += obj->count;
save.c:                  if( file_ver > 1 || obj->wear_loc < -1 || obj->wear_loc >= MAX_WEAR )
save.c:                     obj->wear_loc = -1;
save.c:                     if( obj->timer < 1 )
save.c:                        obj->timer = 40;
save.c:                     if( room->vnum == ROOM_VNUM_HALLOFFALLEN && obj->first_content )
save.c:                        obj->timer = -1;
save.c:            KEY( "ItemType", obj->item_type, fread_number( fp ) );
save.c:            KEY( "Level", obj->level, fread_number( fp ) );
save.c:            KEY( "Name", obj->name, fread_string( fp ) );
save.c:               STRFREE( obj->owner );
save.c:               obj->owner = fread_string( fp );
save.c:               xSET_BIT( obj->extra_flags, ITEM_PERSONAL );
save.c:            KEY( "Rvnum", obj->room_vnum, fread_number( fp ) );
save.c:            KEY( "ShortDescr", obj->short_descr, fread_string( fp ) );
save.c:                  obj->value[iValue] = sn;
save.c:            KEY( "Timer", obj->timer, fread_number( fp ) );
save.c:               obj->value[0] = x1;
save.c:               obj->value[1] = x2;
save.c:               obj->value[2] = x3;
save.c:               obj->value[3] = x4;
save.c:               obj->value[4] = x5;
save.c:               obj->value[5] = x6;
save.c:               if( ( obj->pIndexData = get_obj_index( vnum ) ) == NULL )
save.c:                  obj->cost = obj->pIndexData->cost;
save.c:                  obj->weight = obj->pIndexData->weight;
save.c:                  obj->item_type = obj->pIndexData->item_type;
save.c:                  obj->wear_flags = obj->pIndexData->wear_flags;
save.c:                  obj->extra_flags = obj->pIndexData->extra_flags;
save.c:            KEY( "WearFlags", obj->wear_flags, fread_number( fp ) );
save.c:            KEY( "WearLoc", obj->wear_loc, fread_number( fp ) );
save.c:            KEY( "Weight", obj->weight, fread_number( fp ) );
save.c:         if( obj->name )
save.c:            STRFREE( obj->name );
save.c:         if( obj->description )
save.c:            STRFREE( obj->description );
save.c:         if( obj->short_descr )
save.c:            STRFREE( obj->short_descr );
save.c:         while( ( ed = obj->first_extradesc ) != NULL )
save.c:            UNLINK( ed, obj->first_extradesc, obj->last_extradesc, next, prev );
save.c:         while( ( paf = obj->first_affect ) != NULL )
save.c:            UNLINK( paf, obj->first_affect, obj->last_affect, next, prev );
shops.c:      cost = ( int )( obj->cost * UMAX( ( pShop->profit_sell + 1 ), pShop->profit_buy + profitmod ) ) / 100;
shops.c:         if( obj->item_type == pShop->buy_type[itype] )
shops.c:            cost = ( int )( obj->cost * UMIN( ( pShop->profit_buy - 1 ), pShop->profit_sell + profitmod ) ) / 100;
shops.c:         if( obj->pIndexData == obj2->pIndexData )
shops.c:   if( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND )
shops.c:      cost = ( int )( cost * obj->value[2] / obj->value[1] );
shops.c:      if( obj->item_type == rShop->fix_type[itype] )
shops.c:         if( obj->item_type == ITEM_ARMOR && obj->cost == 0 )
shops.c:            cost = ( int )( ( obj->pIndexData->cost * 66 ) / 100 * rShop->profit_fix / 1000 );
shops.c:         else if( obj->item_type == ITEM_WEAPON && obj->cost == 0 )
shops.c:            cost = ( int )( ( obj->pIndexData->cost * 66 ) / 100 * rShop->profit_fix / 1000 );
shops.c:            cost = ( int )( obj->cost * rShop->profit_fix / 1000 );
shops.c:      switch ( obj->item_type )
shops.c:            if( obj->value[0] >= obj->value[1] )
shops.c:               cost *= ( obj->value[1] - obj->value[0] );
shops.c:            if( INIT_WEAPON_CONDITION == obj->value[0] )
shops.c:               cost *= ( INIT_WEAPON_CONDITION - obj->value[0] );
shops.c:            if( obj->value[2] >= obj->value[1] )
shops.c:               cost *= ( obj->value[1] - obj->value[2] );
shops.c:      if( obj->level > ch->level )
shops.c:                   ( obj->short_descr[strlen( obj->short_descr ) - 1] == 's' ? "" : "s" ) );
shops.c:                   ( obj->short_descr[strlen( obj->short_descr ) - 1] == 's' ? "" : "s" ) );
shops.c:         buy_obj = create_object( obj->pIndexData, obj->level );
shops.c:            bag->value[0] = bag->weight + ( buy_obj->weight * noi );
shops.c:            buy_obj->count = noi;
shops.c:            obj->pIndexData->count += ( noi - 1 );
shops.c:      for( obj = keeper->first_carrying; obj; obj = obj->next_content )
shops.c:         if( obj->wear_loc == WEAR_NONE
shops.c:             && ( cost = get_cost( ch, keeper, obj, TRUE ) ) > 0 && ( arg[0] == '\0' || nifty_is_name( arg, obj->name ) ) )
shops.c:            if( obj->level <= upper )
shops.c:            if( obj->level < lower )
shops.c:            pager_printf( ch, "[%2d %5d] %s.\r\n", obj->level, cost, capitalize( obj->short_descr ) );
shops.c:   if( obj->timer > 0 )
shops.c:   if( obj->item_type == ITEM_TRASH )
shops.c:      ch_printf( ch, "You can't let go of %s.\r\n", obj->short_descr );
shops.c:                cost == 1 ? "" : "s", fixstr, obj->short_descr );
shops.c:      switch ( obj->item_type )
shops.c:            obj->value[0] = obj->value[1];
shops.c:            obj->value[0] = INIT_WEAPON_CONDITION;
shops.c:            obj->value[2] = obj->value[1];
shops.c:      for( obj = ch->first_carrying; obj; obj = obj->next_content )
shops.c:         if( obj->wear_loc == WEAR_NONE
shops.c:             && ( obj->item_type == ITEM_ARMOR
shops.c:                  || obj->item_type == ITEM_WEAPON || obj->item_type == ITEM_WAND || obj->item_type == ITEM_STAFF ) )
shops.c:   for( obj = ch->first_carrying; obj != NULL; obj = obj->next_content )
shops.c:      if( obj->wear_loc == WEAR_NONE
shops.c:          && ( obj->item_type == ITEM_ARMOR
shops.c:               || obj->item_type == ITEM_WEAPON || obj->item_type == ITEM_WAND || obj->item_type == ITEM_STAFF ) )
shops.c:            ch_printf( ch, "You can't let go of %s.\r\n", obj->short_descr );
shops.c:                      cost, cost == 1 ? "" : "s", fixstr, obj->short_descr );
skills.c:   if( ( obj->value[3] != 1 && obj->value[3] != 2 && obj->value[3] != 3 && obj->value[3] != 11 ) || IS_OBJ_STAT( corpse, ITEM_SKINNED ) )
skills.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:            if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
skills.c:         ch->alloc_ptr = str_dup( obj->name );
skills.c:   for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
skills.c:      if( can_see_obj( ch, obj ) && nifty_is_name( arg, obj->name ) )
skills.c:   for( obj = ch->first_carrying; obj; obj = obj->next_content )
skills.c:      if( obj->item_type == ITEM_SHOVEL )
skills.c:   for( obj = startobj; obj; obj = obj->next_content )
skills.c:   xREMOVE_BIT( obj->extra_flags, ITEM_BURIED );
skills.c:   if( obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC )
skills.c:      for( obj = startobj; obj; obj = obj->next_content )
skills.c:            xREMOVE_BIT( obj->extra_flags, ITEM_HIDDEN );
skills.c:       || IS_OBJ_STAT( obj, ITEM_INVENTORY ) || IS_OBJ_STAT( obj, ITEM_PROTOTYPE ) || obj->level > ch->level )
skills.c:   if( ch->carry_number + ( get_obj_number( obj ) / obj->count ) > can_carry_n( ch ) )
skills.c:   if( ch->carry_weight + ( get_obj_weight( obj ) / obj->count ) > can_carry_w( ch ) )
skills.c:       || ( obj->value[3] != 1
skills.c:            && obj->value[3] != 2
skills.c:            && obj->value[3] != 3 && obj->value[3] != 5 && obj->value[3] != 10 && obj->value[3] != 11 ) )
skills.c:   if( ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL || ( obj->value[3] != 11 && obj->value[3] != 2 ) )
skills.c:      obj->timer = 1;
skills.c:      obj->value[1] = 6;
skills.c:      tmpobj->wear_loc = WEAR_WIELD;
skills.c:      SET_BIT( obj->magic_flags, ITEM_PKDISARMED );
skills.c:      STRFREE( obj->action_desc );
skills.c:      obj->action_desc = STRALLOC( buf );
skills.c:      STRFREE( obj->action_desc );  /* Rather do this kludgy stuff than try to test all circumstances */
skills.c:      obj->action_desc = STRALLOC( "" );
skills.c:      STRFREE( obj->action_desc );
skills.c:      obj->action_desc = STRALLOC( "" );
skills.c:       || ( obj->value[3] != 1 && obj->value[3] != 3 && obj->value[3] != 5 ) )
skills.c:      if( obj->item_type != ITEM_CONTAINER )
skills.c:      if( !IS_SET( obj->value[1], CONT_CLOSED ) )
skills.c:      if( obj->value[2] < 0 )
skills.c:      if( !IS_SET( obj->value[1], CONT_LOCKED ) )
skills.c:      if( IS_SET( obj->value[1], CONT_PICKPROOF ) )
skills.c:      REMOVE_BIT( obj->value[1], CONT_LOCKED );
skills.c:   if( obj->item_type != ITEM_WEAPON )
skills.c:   for( pobj = ch->first_carrying; pobj; pobj = pobj->next_content )
skills.c:      if( pobj->pIndexData->vnum == OBJ_VNUM_BLACK_POWDER )
skills.c:   for( wobj = ch->first_carrying; wobj; wobj = wobj->next_content )
skills.c:      if( wobj->item_type == ITEM_DRINK_CON && wobj->value[1] > 0 && wobj->value[2] == 0 )
skills.c:   xSET_BIT( obj->extra_flags, ITEM_POISONED );
skills.c:   obj->cost *= 2;
skills.c:   obj->timer = UMIN( obj->level, ch->level );
skills.c:      obj->timer *= 2;
skills.c:      obj->timer *= 2;
skills.c:   if( ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL || ( obj->value[3] != 11 && obj->value[3] != 2 ) )
skills.c:   for( obj = ch->last_carrying; obj; obj = obj->prev_content )
skills.c:         if( obj->item_type == ITEM_QUIVER && !IS_SET( obj->value[1], CONT_CLOSED ) )
skills.c:            for( obj2 = obj->last_content; obj2; obj2 = obj2->prev_content )
skills.c:         if( obj->item_type == ITEM_PROJECTILE && obj->value[3] == type )
skills.c:	&& ( throw_obj->wear_loc == WEAR_HELD || throw_obj->wear_loc == 
skills.c:	WEAR_WIELDED || throw_obj->wear_loc == WEAR_DUAL_WIELDED )
skills.c:	&& nifty_is_name( arg, throw_obj->name ) )
skills.c:    if ( can_see_obj( ch, throw_obj ) && nifty_is_name( arg, throw_obj->name )
skills.c:  if ( ( throw_obj->item_type != ITEM_WEAPON)
skills.c:        act( AT_GREY, "Throw $t at whom?", ch, obj->short_descr, NULL,  
skills.c:       || ( obj->value[3] != 1 && obj->value[3] != 2 && obj->value[3] != 3 && obj->value[3] != 11 ) )
special.c:         obj_next = obj->next_content;
update.c:         for( obj = ch->in_room->first_content; obj; obj = obj->next_content )
update.c:            if( CAN_WEAR( obj, ITEM_TAKE ) && obj->cost > max && !IS_OBJ_STAT( obj, ITEM_BURIED ) && !IS_OBJ_STAT( obj, ITEM_HIDDEN ) )
update.c:               max = obj->cost;
update.c:      if( obj->carried_by )
update.c:      else if( obj->in_room && obj->in_room->area->nplayer > 0 )
update.c:      if( obj->item_type == ITEM_LIGHT )
update.c:         if( ( tch = obj->carried_by ) )
update.c:                     || ( IS_SET( obj->value[3], PIPE_LIT ) ) ) && ( obj->value[2] > 0 ) )
update.c:               if( --obj->value[2] == 0 && tch->in_room )
update.c:                  tch->in_room->light -= obj->count;
update.c:                  if( obj->serial == cur_obj )
update.c:         else if( obj->in_room )
update.c:            if( IS_SET( obj->value[3], PIPE_LIT ) && ( obj->value[2] > 0 ) )
update.c:               if( --obj->value[2] == 0 )
update.c:                  obj->in_room->light -= obj->count;
update.c:                  if( obj->in_room->light < 0 )
update.c:                     obj->in_room->light = 0;
update.c:                  if( ( tch = obj->in_room->first_person ) )
update.c:                  if( obj->serial == cur_obj )
update.c:      if( obj->item_type == ITEM_PIPE )
update.c:         if( IS_SET( obj->value[3], PIPE_LIT ) )
update.c:            if( --obj->value[1] <= 0 )
update.c:               obj->value[1] = 0;
update.c:               REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c:            else if( IS_SET( obj->value[3], PIPE_HOT ) )
update.c:               REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c:               if( IS_SET( obj->value[3], PIPE_GOINGOUT ) )
update.c:                  REMOVE_BIT( obj->value[3], PIPE_LIT );
update.c:                  REMOVE_BIT( obj->value[3], PIPE_GOINGOUT );
update.c:                  SET_BIT( obj->value[3], PIPE_GOINGOUT );
update.c:            if( !IS_SET( obj->value[3], PIPE_LIT ) )
update.c:               SET_BIT( obj->value[3], PIPE_FULLOFASH );
update.c:            REMOVE_BIT( obj->value[3], PIPE_HOT );
update.c:      if( obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC )
update.c:         short timerfrac = UMAX( 1, obj->timer - 1 );
update.c:         if( obj->item_type == ITEM_CORPSE_PC )
update.c:            timerfrac = ( int )( obj->timer / 8 + 1 );
update.c:         if( obj->timer > 0 && obj->value[2] > timerfrac )
update.c:            bufptr = one_argument( obj->short_descr, name );
update.c:            obj->value[2] = timerfrac;
update.c:            STRFREE( obj->description );
update.c:            obj->description = STRALLOC( buf );
update.c:      if( IS_OBJ_STAT( obj, ITEM_GROUNDROT ) && !obj->in_room )
update.c:      if( ( obj->timer <= 0 || --obj->timer > 0 ) )
update.c:      switch ( obj->item_type )
update.c:            obj->item_type = ITEM_TRASH;  /* so extract_obj  */
update.c:      if( obj->carried_by )
update.c:         act( AT_TEMP, message, obj->carried_by, obj, NULL, TO_CHAR );
update.c:      else if( obj->in_room && ( rch = obj->in_room->first_person ) != NULL && !IS_OBJ_STAT( obj, ITEM_BURIED ) )
update.c:      if( obj->serial == cur_obj )
update.c:               for( obj = ch->first_carrying; obj; obj = obj->next_content )
update.c:                  if( obj->item_type == ITEM_BOAT )
update.c:                && ( obj->value[3] == 11 || obj->value[3] == 2 ) && !victim->fighting && victim->hit >= victim->max_hit )
